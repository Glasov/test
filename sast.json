{"$schema":"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/3a361e0bc07860055a926e0d41df405c6f0eb3d4/Documents/CommitteeSpecifications/2.1.0/sarif-schema-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"appScreener","organization":"Solar appScreener","product":"appScreener","fullName":"Solar appScreener","version":"3.14.3","notifications":[],"rules":[{"id":"C_PRECISION_LOSS","deprecatedIds":[],"deprecatedGuids":[],"name":"Loss of precision","deprecatedNames":[],"fullDescription":{"markdown":"<p>Loss of recision can occur when:</p>\n\n<ol>\n<li>A negative value is implicitly converted to an unsigned value in an assignment, comparison or multiplication.</li>\n<li>Assignment/initialization when source value is greater than the max value of target.</li>\n</ol>"},"help":{"markdown":"<ul>\n<li>If possible, avoid conversions with numeric types.</li>\n<li>Always check the valid ranges.</li>\n</ul>"},"relationships":[]},{"id":"C_SENSITIVE_DATA_HARDCODED","deprecatedIds":[],"deprecatedGuids":[],"name":"Hardcoded sensitive data","deprecatedNames":[],"fullDescription":{"markdown":"<p>Sensitive data is hardcoded. This may lead to an application data compromise.</p>\n\n<p>Eliminating security risks related to hardcoded sensitive data (e.g. PIN codes, CVV numbers, etc.) is extremely difficult. This data is at least accessible to every developer of the application. Moreover, after the application is installed, removing sensitive data from its code is possible only via an update. Constant strings are easily extracted from the compiled application by decompilers. Therefore, an attacker does not necessarily need to have an access to the source code to get access to the data. If it becomes known to an attacker, system administrators will be forced either to neglect the safety, or to restrict the access to the application.</p>\n\n<p>In case of a mobile application, security threat is even higher, considering the risk of the device loss.</p>"},"help":{"markdown":"<ul>\n<li>Store not the sensitive data but rather the values of cryptographically secure hash function from the data. Use specialized hash functions designed for this purpose. Use salt obtained from cryptographically secure pseudorandom number generator to resist attacks which use rainbow tables.</li>\n<li>Store authentication information in an encrypted form in a separate configuration file or in a database. Secure the encryption key. If encryption is not possible, limit the access to the repository as much as possible.</li>\n</ul>"},"relationships":[]},{"id":"C_NULL_POINT_ARGUMENT","deprecatedIds":[],"deprecatedGuids":[],"name":"Function calling with invalid null argument","deprecatedNames":[],"fullDescription":{"markdown":"<p>The function is called with invalid null argument. This may lead to incorrect behavior of the application.</p>\n\n<p>The function is used with arguments whose values should not be <code>NULL</code>, however, checking for null is not performed. Undefined behavior of the application is possible.</p>"},"help":{"markdown":"<ul>\n<li>Check the argument for equality to <code>null</code> before calling corresponding function.</li>\n</ul>"},"relationships":[]},{"id":"C_INFORMATION_LEAK_INTERNAL","deprecatedIds":[],"deprecatedGuids":[],"name":"Internal information leak","deprecatedNames":[],"fullDescription":{"markdown":"<p>System configuration information leak is possible. This can help an attacker to plan an attack.</p>\n\n<p>Debug information and error messages can be written to the log, displayed to the console, or sent to the user depending on the system settings. In some cases, an attacker can make a conclusion about the system vulnerabilities from the error message. For example, a database error can indicate insecurity against SQL injection attacks. Information about the version of the operating system, application server and system configuration can also be of value to the attacker.</p>\n\n<p>In this case, we are talking about an internal leak: system information is stored in the local file or event log or is displayed on the screen.</p>"},"help":{"markdown":"<ul>\n<li>Exclude detailed information about the system and its configuration from the error messages.</li>\n</ul>"},"relationships":[]},{"id":"C_UNSAFE_ALTERNATIVE","deprecatedIds":[],"deprecatedGuids":[],"name":"Using an insecure method","deprecatedNames":[],"fullDescription":{"markdown":"<p>There is a safer analogue to the function to be called. For example, for many functions whose execution may lead to buffer overflow, there are analogues that check the buffer size: use <code>PathCchAppend</code> instead of <code>PathAppend</code>, <code>memcpy_s</code> instead of <code>memcpy</code>.</p>"},"help":{"markdown":"<ul>\n<li>Use <code>PathCchAppend</code> instead of <code>PathAppend</code>, <code>memcpy_s</code> instead of <code>memcpy</code>.</li>\n</ul>"},"relationships":[]},{"id":"C_DEPRECATED","deprecatedIds":[],"deprecatedGuids":[],"name":"Deprecated construct","deprecatedNames":[],"fullDescription":{"markdown":"<p>A deprecated language construction is used. This may lead to security and compatibility issues.</p>\n\n<p>Frameworks and APIs are constantly being improved. Some language constructions are deprecated and replaced with more functional and secure analogues. It is recommended to replace deprecated constructions with modern analogues.</p>"},"help":{"markdown":"<ul>\n<li>Use modern analogues.</li>\n</ul>"},"relationships":[]},{"id":"C_SWITCH_MISSING_DEFAULT","deprecatedIds":[],"deprecatedGuids":[],"name":"Switch missing default","deprecatedNames":[],"fullDescription":{"markdown":"<p>A <code>switch</code> statement missing <code>default</code> label.</p>\n\n<p>The use of <code>default</code> label can aid in avioding mistakes and can be used for the following reasons:</p>\n\n<ul>\n<li>Perform some action if the variable has unexpected value.</li>\n<li>Handle default cases, while special ones are handled under <code>case</code> labels.</li>\n<li>The one reading the code can crearly see that all cases are covered.</li>\n</ul>"},"help":{"markdown":"<ul>\n<li>Add code for other cases under <code>default</code> label.</li>\n</ul>"},"relationships":[]},{"id":"C_ARRAY_INDEX_TAINTED","deprecatedIds":[],"deprecatedGuids":[],"name":"Array index tainted","deprecatedNames":[],"fullDescription":{"markdown":"<p>Array index is tainted. This may cause array bounds violation.</p>"},"help":{"markdown":"<ul>\n<li>While writing code, make sure that the program does not violate array boundaries.</li>\n</ul>"},"relationships":[]},{"id":"C_INSECURE_API_SETUID","deprecatedIds":[],"deprecatedGuids":[],"name":"Unsafe function: setuid","deprecatedNames":[],"fullDescription":{"markdown":"<p>The application defines a function that uses <code>setuid</code> but does not check the returned value. This may lead to incorrect behavior of the application, crash, or violation of valuable data confidentiality.</p>\n\n<p><code>setuid</code> and <code>setgid</code> are permission flags in Unix-like operating systems that allow users to run executable files with the privileges of the owner or group of the executable file. If an error occurs in this function, the following code may be executed not with the privileges that the developer expects.</p>"},"help":{"markdown":"<ul>\n<li>Check the return value of <code>setuid</code> and its analogues.</li>\n</ul>"},"relationships":[]},{"id":"C_DEAD_STORE","deprecatedIds":[],"deprecatedGuids":[],"name":"Dead store","deprecatedNames":[],"fullDescription":{"markdown":"<p>A local variable is assigned a value but is not read by any subsequent instruction. Dead stores waste processor time and memory and may indicate significant logic errors.</p>"},"help":{"markdown":"<ul>\n<li>Remove the unused variable from the source.</li>\n<li>In compiler theory, there are DCE (dead code elimination) algorithms that remove dead code.</li>\n</ul>"},"relationships":[]},{"id":"C_NULL_DEREFERENCE","deprecatedIds":[],"deprecatedGuids":[],"name":"Null dereference","deprecatedNames":[],"fullDescription":{"markdown":"<p>Null pointer dereference may occur. This may lead to incorrect behavior of the application.</p>\n\n<p>The null pointer dereferencing is an operation with undefined behavior. For the implementation there are no restrictions: for example, a memory access that was not intended for the use of this program can happen (that is, when reading will be read &ldquo;garbage&rdquo;, and when writing a value will be written to the memory area does not belong to the program).</p>\n\n<p>A null pointer dereference takes place when a pointer with NULL value is used as though it pointed to a valid memory area.</p>\n\n<p>Null pointer errors are usually the result of programmer assumptions violation. Most null pointer issues result in general software reliability problems, but if an attacker can intentionally trigger a null pointer dereference, he might be able to use the resulting exception to bypass security logic or gain access to the app debugging information.</p>\n\n<p>Null pointer dereferences, while common, can generally be found and corrected in a simple way. Usually they will always result in the crash of the process.</p>"},"help":{"markdown":"<ul>\n<li>Before dereferencing a pointer, check it for equality to <code>NULL</code>.</li>\n</ul>"},"relationships":[]},{"id":"C_PRIVACY_VIOLATION_HEAP","deprecatedIds":[],"deprecatedGuids":[],"name":"Privacy violation from a memory dump","deprecatedNames":[],"fullDescription":{"markdown":"<p>Some functions to work with the heap, for example <code>realloc()</code> can make sensitive data available to an attacker.</p>\n\n<p>If valuable data (passwords, credit card numbers, etc.) is not deleted from memory immediately after use, leak is possible.</p>"},"help":{"markdown":"<ul>\n<li>Delete valuable data as soon as it no longer needs to be stored.</li>\n</ul>"},"relationships":[]},{"id":"C_INSECURE_API_STR","deprecatedIds":[],"deprecatedGuids":[],"name":"Insecure string API","deprecatedNames":[],"fullDescription":{"markdown":"<p>The string manipulation function used is insecure, since it allows a buffer overflow. Insecure functions include: <code>strcpy</code>, <code>strcat</code>. This may lead to incorrect behavior of the application, crash, or violation of valuable data confidentiality.</p>\n\n<p>The <code>strcpy()</code> function copies the C string pointed by source into the array pointed by destination, including the terminating null character. The <code>strcat</code> appends a copy of the source string to the destination string. It is important to note that, the destination array should be large enough otherwise it may result in undefined behavior.</p>"},"help":{"markdown":"<ul>\n<li>Use secure analogues (<code>strncpy</code>).</li>\n</ul>"},"relationships":[]},{"id":"C_INJECTION_COMMAND","deprecatedIds":[],"deprecatedGuids":[],"name":"Command injection","deprecatedNames":[],"fullDescription":{"markdown":"<p>Executing commands obtained from data from an untrusted source is insecure.</p>\n\n<p>Injection vulnerabilities take the first place in the &ldquo;OWASP Top 10 2017&rdquo; web-application vulnerabilities ranking. Command injection vulnerabilities are divided into two categories:</p>\n\n<ol>\n<li>An attacker modifies the command itself;</li>\n<li>An attacker replaces the value of the environment variables, which implicitly changes the semantics of the command being executed.</li>\n</ol>\n\n<p>In the given case, the application is prone to the vulnerability of the first type.</p>\n\n<p>A possible attack scenario:</p>\n\n<ol>\n<li>The application receives input data from an untrusted source, for example, user input.</li>\n<li>The data obtained is used as a part of the string that defines the command.</li>\n<li>Execution of the command gives an attacker the privileges which he did not previously possess.</li>\n</ol>"},"help":{"markdown":"<ul>\n<li>Do not allow users to directly control the commands executed by an application. If the behavior of the application should be dependent on the user input, suggest the user to choose from a specific list of legitimate commands.</li>\n<li>If user data is a command argument, the whitelist may be too cumbersome. Blacklist is also inefficient, as it is difficult to maintain it up to date and comprehensive. In this case, it is recommended to use the whitelist of characters allowed in the command parameters.</li>\n<li>An attacker can change the semantics of the command not only by changing it, but also by affecting its environment. Environment must not be considered a trusted source. The values of environment variables must also be validated.</li>\n</ul>"},"relationships":[]},{"id":"C_NONNULL_PARAMETER_NULL","deprecatedIds":[],"deprecatedGuids":[],"name":"Null pointer in non-null parameter","deprecatedNames":[],"fullDescription":{"markdown":"<p>Null pointer passed as an argument to a parameter declared with non-null attribute.</p>"},"help":{"markdown":"<ul>\n<li>Make sure that null pointers are not passed to parameters with non-null attributes.</li>\n</ul>"},"relationships":[]},{"id":"C_OBSOLETE","deprecatedIds":[],"deprecatedGuids":[],"name":"Obsolete construct","deprecatedNames":[],"fullDescription":{"markdown":"<p>The obsolete function is used. Perhaps, the code has not been developed for a long time.</p>\n\n<p>In the development of the programming language, some constructions become deprecated. This may be due to improvements of the language, or changes in agreements on how to conduct certain operations.</p>\n\n<p>Deprecated methods are usually replaced by new ones that perform the same action more efficiently and securely.</p>"},"help":{"markdown":"<ul>\n<li>Use modern language constructs.</li>\n</ul>"},"relationships":[]},{"id":"C_INTEGER_OVERFLOW","deprecatedIds":[],"deprecatedGuids":[],"name":"Signed integer overflow","deprecatedNames":[],"fullDescription":{"markdown":"<p>Signed integer overflow.</p>\n\n<p>Unlike unsigned integer overflow, signed integer overflow is undefined behavior.</p>"},"help":{"markdown":"<ul>\n<li>Use types that can store any valid value.</li>\n<li>Always check the valid ranges and use types of sufficient size.</li>\n</ul>"},"relationships":[]},{"id":"C_INSECURE_API_GETHOST","deprecatedIds":[],"deprecatedGuids":[],"name":"DNS lookup usage for an authentication","deprecatedNames":[],"fullDescription":{"markdown":"<p>Usage of <code>gethostbyaddr</code> and <code>gethostbyname</code> functions for an authentication purposes is unsafe because of the return value could be modified by an attacker.</p>"},"help":{"markdown":"<ul>\n<li>Do not use host name or address as the only mean of authentification.</li>\n</ul>"},"relationships":[]},{"id":"C_FORMAT_STRING","deprecatedIds":[],"deprecatedGuids":[],"name":"Unsafe format string","deprecatedNames":[],"fullDescription":{"markdown":"<p>The application uses an insecure format string. If formatting arguments come from an untrusted source, an attacker can disrupt the structure of the string or cause a buffer overflow, which leads to application crash or valuable data leak.</p>\n\n<p>String format functions accept any number of arguments and can not determine how many arguments are passed in a particular call. If you pass fewer arguments than the format string provides, the missing data may be taken from the stack, which, in general, contains the data not related to the current call.</p>\n\n<p>Format string vulnerabilities are characteristic of C language. All C constructions are correct in Objective-C, so applications in Objective-C are also vulnerable when using C API.</p>"},"help":{"markdown":"<ul>\n<li>Use a secure API for working with strings.</li>\n<li>Do not use unvalidated data from an untrusted source when formatting strings.</li>\n</ul>"},"relationships":[]},{"id":"C_ARRAY_OUT_OF_BOUNDS","deprecatedIds":[],"deprecatedGuids":[],"name":"Reference to array element out of bounds","deprecatedNames":[],"fullDescription":{"markdown":"<p>Call of the element out of array bounds may lead to incorrect application behavior, crashes, or data leak. If you erroneously call the element out of array bounds, the program reads the contents of memory cells not belonging to the array, or writes something, spoiling the contents of other variables, perhaps in other programs, and then continues its work.</p>\n\n<p>Specific overflows, such as overflow in a stack frame, allow an attacker to download and execute arbitrary machine code on behalf of the program and with the rights of the account from which it is executed.</p>\n\n<p>Unlike memory-safe languages (e.g., Java), C does not provide built-in mechanisms to detect incorrect operations with memory.</p>"},"help":{"markdown":"<ul>\n<li>Check the correctness of the indices when working with arrays.</li>\n</ul>"},"relationships":[]},{"id":"C_TYPE_CAST_ERROR","deprecatedIds":[],"deprecatedGuids":[],"name":"Type cast error","deprecatedNames":[],"fullDescription":{"markdown":"<p>Incorrect type cast: a pointer to the larger type is cast to a pointer to the smaller type. This may lead to incorrect behavior of the application. Part of the data stored in the variable will be lost.</p>"},"help":{"markdown":"<ul>\n<li>Use the correct type cast: do not cast a pointer to a variable to a pointer to a smaller type.</li>\n</ul>"},"relationships":[]}],"taxa":[],"locations":[],"language":"en-US","contents":["localizedData","nonLocalizedData"],"isComprehensive":false,"supportedTaxonomies":[]},"extensions":[]},"invocations":[],"language":"en-US","versionControlProvenance":[],"artifacts":[],"logicalLocations":[],"graphs":[],"results":[{"ruleId":"C_NONNULL_PARAMETER_NULL","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Null pointer in non-null parameter","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/xmalloc.c","index":-1},"region":{"startLine":71,"endLine":71,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/xmalloc.c","lineStart":71,"lineEnd":71,"columnStart":2,"columnEnd":17,"description":"strncpy(t, s, n)","snippet":"\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"},{"position":1,"source":"src/xmalloc.c","lineStart":67,"lineEnd":67,"columnStart":6,"columnEnd":11,"description":"s == NULL","snippet":"\nchar *xstrndup(const char *s, int n)\n{\n\tchar *t;\n\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_INTEGER_OVERFLOW","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Signed integer overflow","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":53,"endLine":53,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t * sequential 16 bit words to it, and at the end, fold back all the\n\t * carry bits from the top 16 bits into the lower 16 bits.\n\t */\n\twhile (nleft > 1) {\n\t\tsum += *w++;\n\t\tnleft -= 2;\n\t}\t\t\t/* mop up an odd byte, if necessary */\n\tif (nleft == 1) {\n\t\tsum += htons(*(unsigned char *) w << 8);\n\t}\n\t/* add back carry outs from top 16 bits to low 16 bits */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/net.c","lineStart":53,"lineEnd":53,"columnStart":9,"columnEnd":9,"description":"nleft -= 2","snippet":"\t * sequential 16 bit words to it, and at the end, fold back all the\n\t * carry bits from the top 16 bits into the lower 16 bits.\n\t */\n\twhile (nleft > 1) {\n\t\tsum += *w++;\n\t\tnleft -= 2;\n\t}\t\t\t/* mop up an odd byte, if necessary */\n\tif (nleft == 1) {\n\t\tsum += htons(*(unsigned char *) w << 8);\n\t}\n\t/* add back carry outs from top 16 bits to low 16 bits */"},{"position":1,"source":"src/net.c","lineStart":107,"lineEnd":107,"columnStart":19,"columnEnd":62,"description":"in_cksum((unsigned short *)icp, DATALEN + 8)","snippet":"\t\ticp->code = icp->checksum = 0;\n\t\ticp->un.echo.sequence = htons(i + 1);\n\t\ticp->un.echo.id = htons(daemon_pid);\t/* ID */\n\n\t\t/* compute ICMP checksum here */\n\t\ticp->checksum = in_cksum((unsigned short *)icp, DATALEN + 8);\n\n\t\t/* and send it out */\n\t\tif (sendto(sock_fp, (char *)outpack, DATALEN + 8, 0, &to, sizeof(struct sockaddr)) < 0) {\n\t\t\tint err = errno;\n"},{"position":2,"source":"src/net.c","lineStart":79,"lineEnd":79,"columnStart":6,"columnEnd":14,"description":"count < 1","snippet":"\tldiv_t d;\n\n\tif (target == NULL)\n\t\treturn (ENOERR);\n\n\tif (count < 1)\n\t\treturn (EINVAL);\n\n\tmemset(outpack, 0, sizeof(outpack));\n\n\t/* set the timeout value */"},{"position":3,"source":"src/net.c","lineStart":76,"lineEnd":76,"columnStart":6,"columnEnd":16,"description":"target == NULL","snippet":"\tint i;\n\tunsigned char outpack[MAXPACKET];\n\tstruct timeval tmax;\n\tldiv_t d;\n\n\tif (target == NULL)\n\t\treturn (ENOERR);\n\n\tif (count < 1)\n\t\treturn (EINVAL);\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":125,"endLine":125,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\treturn (err);\n\t\t}\n\n\t\tgettimeofday(&tstart, NULL);\n\t\t/* set the timeout value */\n\t\ttimeradd(&tstart, &tmax, &timeout);\n\n\t\t/* wait for reply */\n\t\tFD_ZERO(&fdmask);\n\t\tFD_SET(sock_fp, &fdmask);\n\t\twhile (1) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/net.c","lineStart":125,"lineEnd":125,"columnStart":3,"columnEnd":3,"description":"timeradd(&tstart, &tmax, &timeout)","snippet":"\t\t\treturn (err);\n\t\t}\n\n\t\tgettimeofday(&tstart, NULL);\n\t\t/* set the timeout value */\n\t\ttimeradd(&tstart, &tmax, &timeout);\n\n\t\t/* wait for reply */\n\t\tFD_ZERO(&fdmask);\n\t\tFD_SET(sock_fp, &fdmask);\n\t\twhile (1) {"},{"position":1,"source":"src/net.c","lineStart":110,"lineEnd":110,"columnStart":7,"columnEnd":88,"description":"sendto(sock_fp, (char *)outpack, DATALEN + 8, 0, &to, sizeof(struct sockaddr)) < 0","snippet":"\n\t\t/* compute ICMP checksum here */\n\t\ticp->checksum = in_cksum((unsigned short *)icp, DATALEN + 8);\n\n\t\t/* and send it out */\n\t\tif (sendto(sock_fp, (char *)outpack, DATALEN + 8, 0, &to, sizeof(struct sockaddr)) < 0) {\n\t\t\tint err = errno;\n\n\t\t\t/* if our kernel tells us the network is unreachable we are done */\n\t\t\tif (err == ENETUNREACH) {\n\t\t\t\tlog_message(LOG_ERR, \"network is unreachable (target: %s)\", target);"},{"position":2,"source":"src/net.c","lineStart":79,"lineEnd":79,"columnStart":6,"columnEnd":14,"description":"count < 1","snippet":"\tldiv_t d;\n\n\tif (target == NULL)\n\t\treturn (ENOERR);\n\n\tif (count < 1)\n\t\treturn (EINVAL);\n\n\tmemset(outpack, 0, sizeof(outpack));\n\n\t/* set the timeout value */"},{"position":3,"source":"src/net.c","lineStart":76,"lineEnd":76,"columnStart":6,"columnEnd":16,"description":"target == NULL","snippet":"\tint i;\n\tunsigned char outpack[MAXPACKET];\n\tstruct timeval tmax;\n\tldiv_t d;\n\n\tif (target == NULL)\n\t\treturn (ENOERR);\n\n\tif (count < 1)\n\t\treturn (EINVAL);\n"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_UNSAFE_ALTERNATIVE","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Using an insecure method","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1057,"endLine":1057,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t*mtmp = *mc;\n\t\t\t\tmtmp->nxt = 0;\n\t\t\t\tg = NULL;\n\t\t\t\tif (optfork) {\n\t\t\t\t\tif (stat(mc->mnt_fsname, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)) {\n\t\t\t\t\t\tsprintf(major, \"#%x\", DISKMAJOR(statbuf.st_rdev));\n\t\t\t\t\t\tg = major;\n\t\t\t\t\t}\n#if HAVE_NFS\n\t\t\t\t\tif (strcmp(mc->mnt_type, \"nfs\") == 0) {\n\t\t\t\t\t\tg = xstrdup(mc->mnt_fsname);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":1057,"lineEnd":1057,"columnStart":7,"columnEnd":7,"description":"sprintf(major, \"#%x\", DISKMAJOR(statbuf.st_rdev))","snippet":"\t\t\t\t*mtmp = *mc;\n\t\t\t\tmtmp->nxt = 0;\n\t\t\t\tg = NULL;\n\t\t\t\tif (optfork) {\n\t\t\t\t\tif (stat(mc->mnt_fsname, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)) {\n\t\t\t\t\t\tsprintf(major, \"#%x\", DISKMAJOR(statbuf.st_rdev));\n\t\t\t\t\t\tg = major;\n\t\t\t\t\t}\n#if HAVE_NFS\n\t\t\t\t\tif (strcmp(mc->mnt_type, \"nfs\") == 0) {\n\t\t\t\t\t\tg = xstrdup(mc->mnt_fsname);"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/heartbeat.c","index":-1},"region":{"startLine":65,"endLine":65,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tmemcpy(timestamps + (TS_SIZE * lastts), rbuf, TS_SIZE);\n\t\t\t\tnext_value();\n\t\t\t}\n\t\t\t/* Write an indication that the watchdog has started to the heartbeat file */\n\t\t\t/* copy it to the buffer */\n\t\t\tsprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\");\n\t\t\tmemcpy(timestamps + (lastts * TS_SIZE), rbuf, TS_SIZE);\n\n\t\t\t/* success */\n\t\t\tnext_value();\n\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/heartbeat.c","lineStart":65,"lineEnd":65,"columnStart":4,"columnEnd":4,"description":"sprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\")","snippet":"\t\t\t\tmemcpy(timestamps + (TS_SIZE * lastts), rbuf, TS_SIZE);\n\t\t\t\tnext_value();\n\t\t\t}\n\t\t\t/* Write an indication that the watchdog has started to the heartbeat file */\n\t\t\t/* copy it to the buffer */\n\t\t\tsprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\");\n\t\t\tmemcpy(timestamps + (lastts * TS_SIZE), rbuf, TS_SIZE);\n\n\t\t\t/* success */\n\t\t\tnext_value();\n\t\t}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lock_mem.c","index":-1},"region":{"startLine":71,"endLine":71,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"#endif /* _POSIX_MEMLOCK */\n\n\t/* tell oom killer to not kill this process */\n\tif (pid > 0) {\n#ifdef OOM_SCORE_ADJ_MIN\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%d/oom_score_adj\", (int)pid);\n\t\tif (!oom_adjusted) {\t/* Or do both ? */\n\t\t\tif (!stat(buf, &s)) {\n\t\t\t\tfp = fopen(buf, \"w\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"%d\\n\", OOM_SCORE_ADJ_MIN);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lock_mem.c","lineStart":71,"lineEnd":71,"columnStart":3,"columnEnd":3,"description":"snprintf(buf, sizeof(buf), \"/proc/%d/oom_score_adj\", (int)pid)","snippet":"#endif /* _POSIX_MEMLOCK */\n\n\t/* tell oom killer to not kill this process */\n\tif (pid > 0) {\n#ifdef OOM_SCORE_ADJ_MIN\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%d/oom_score_adj\", (int)pid);\n\t\tif (!oom_adjusted) {\t/* Or do both ? */\n\t\t\tif (!stat(buf, &s)) {\n\t\t\t\tfp = fopen(buf, \"w\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"%d\\n\", OOM_SCORE_ADJ_MIN);"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lock_mem.c","index":-1},"region":{"startLine":85,"endLine":85,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t}\n\t\t}\n#endif /* OOM_SCORE_ADJ_MIN */\n\n#ifdef OOM_DISABLE\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%d/oom_adj\", (int)pid);\n\t\tif (!oom_adjusted) {\t/* Or do both ? */\n\t\t\tif (!stat(buf, &s)) {\n\t\t\t\tfp = fopen(buf, \"w\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"%d\\n\", OOM_DISABLE);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lock_mem.c","lineStart":85,"lineEnd":85,"columnStart":3,"columnEnd":3,"description":"snprintf(buf, sizeof(buf), \"/proc/%d/oom_adj\", (int)pid)","snippet":"\t\t\t}\n\t\t}\n#endif /* OOM_SCORE_ADJ_MIN */\n\n#ifdef OOM_DISABLE\n\t\tsnprintf(buf, sizeof(buf), \"/proc/%d/oom_adj\", (int)pid);\n\t\tif (!oom_adjusted) {\t/* Or do both ? */\n\t\t\tif (!stat(buf, &s)) {\n\t\t\t\tfp = fopen(buf, \"w\");\n\t\t\t\tif (fp) {\n\t\t\t\t\tfprintf(fp, \"%d\\n\", OOM_DISABLE);"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/iface.c","index":-1},"region":{"startLine":44,"endLine":44,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t} else {\n\t\t\tint i = 0;\n\n\t\t\tfor (; line[i] == ' ' || line[i] == '\\t'; i++) ;\n\t\t\tif (strncmp(line + i, dev->name, strlen(dev->name)) == 0) {\n\t\t\t\tunsigned long bytes = strtoul(line + i + strlen(dev->name) + 1, NULL, 10);\n\n\t\t\t\t/* do verbose logging */\n\t\t\t\tif (verbose && logtick && ticker == 1)\n\t\t\t\t\tlog_message(LOG_DEBUG, \"device %s received %lu bytes\", dev->name, bytes);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/memory.c","index":-1},"region":{"startLine":101,"endLine":101,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\treturn (EINVMEM);\n\t}\n\n\t/* we only care about integer values */\n\tfreemem  = atoi(ptr1 + strlen(FREEMEM));\n\tfreeswap = atoi(ptr2 + strlen(FREESWAP));\n\tfree = freemem + freeswap;\n\n\tif (verbose && logtick && ticker == 1)\n\t\tlog_message(LOG_DEBUG, \"currently there are %u + %u kB of free memory+swap available\", freemem, freeswap);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":127,"endLine":127,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else\n\tvsprintf(buf, fmt, args);\n#endif\n\tva_end(args);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/logmessage.c","lineStart":127,"lineEnd":127,"columnStart":2,"columnEnd":2,"description":"vsnprintf(buf, sizeof(buf) - 1, fmt, args)","snippet":"\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else\n\tvsprintf(buf, fmt, args);\n#endif\n\tva_end(args);\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":432,"endLine":432,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tbreak;\n\t\tcase 'v':\n\t\t\tverbose = TRUE;\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcount_max = atol(optarg);\n\t\t\tlog_message(LOG_WARNING, \"NOTE: Using --loop-exit so daemon will exit after %ld time intervals\",\n\t\t\t\t    count_max);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(progname);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":172,"endLine":172,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif ((fd = open(device, mode)) < 0) {\n\t\tperror(device);\n\t\treturn 1;\n\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));\n\tstrncpy(loopinfo.lo_name, file, LO_NAME_SIZE);\n\tloopinfo.lo_name[LO_NAME_SIZE - 1] = 0;\n\tif (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))\n\t    < 0) {\n\t\tfprintf(stderr, \"Unsupported encryption type %s\\n\", encryption);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":172,"lineEnd":172,"columnStart":2,"columnEnd":2,"description":"memset(&loopinfo, 0, sizeof(loopinfo))","snippet":"\tif ((fd = open(device, mode)) < 0) {\n\t\tperror(device);\n\t\treturn 1;\n\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));\n\tstrncpy(loopinfo.lo_name, file, LO_NAME_SIZE);\n\tloopinfo.lo_name[LO_NAME_SIZE - 1] = 0;\n\tif (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))\n\t    < 0) {\n\t\tfprintf(stderr, \"Unsupported encryption type %s\\n\", encryption);"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":906,"endLine":906,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (loop) {\n\t\t\t\t\topts = opts0;\n\t\t\t\t\ttype = type0;\n\t\t\t\t}\n\t\t\t\tif (opts) {\n\t\t\t\t\topts = realloc(xstrdup(opts), strlen(opts) + 4);\n\t\t\t\t\tstrcat(opts, \",ro\");\n\t\t\t\t} else\n\t\t\t\t\topts = \"ro\";\n\t\t\t\tif (type && !strcmp(type, \"guess\"))\n\t\t\t\t\ttype = 0;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/heartbeat.c","index":-1},"region":{"startLine":66,"endLine":66,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tnext_value();\n\t\t\t}\n\t\t\t/* Write an indication that the watchdog has started to the heartbeat file */\n\t\t\t/* copy it to the buffer */\n\t\t\tsprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\");\n\t\t\tmemcpy(timestamps + (lastts * TS_SIZE), rbuf, TS_SIZE);\n\n\t\t\t/* success */\n\t\t\tnext_value();\n\t\t}\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/heartbeat.c","lineStart":66,"lineEnd":66,"columnStart":4,"columnEnd":4,"description":"memcpy(timestamps + (lastts * TS_SIZE), rbuf, TS_SIZE)","snippet":"\t\t\t\tnext_value();\n\t\t\t}\n\t\t\t/* Write an indication that the watchdog has started to the heartbeat file */\n\t\t\t/* copy it to the buffer */\n\t\t\tsprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\");\n\t\t\tmemcpy(timestamps + (lastts * TS_SIZE), rbuf, TS_SIZE);\n\n\t\t\t/* success */\n\t\t\tnext_value();\n\t\t}\n\t}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mntent.c","index":-1},"region":{"startLine":185,"endLine":185,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tme.mnt_opts = unmangle(s);\n\ts = skip_nonspaces(s);\n\ts = skip_spaces(s);\n\n\tif (isdigit(*s)) {\n\t\tme.mnt_freq = atoi(s);\n\t\twhile (isdigit(*s))\n\t\t\ts++;\n\t} else\n\t\tme.mnt_freq = 0;\n\tif (*s && !is_space_or_tab(*s))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/xmalloc.c","index":-1},"region":{"startLine":71,"endLine":71,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/xmalloc.c","lineStart":71,"lineEnd":71,"columnStart":2,"columnEnd":2,"description":"strncpy(t, s, n)","snippet":"\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":147,"endLine":147,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"void fatal_error(int exitcode, const char *fmt, ...)\n{\n\tchar buf[MAX_MESSAGE];\n\tva_list args;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/logmessage.c","lineStart":147,"lineEnd":147,"columnStart":2,"columnEnd":2,"description":"memset(buf, 0, sizeof(buf))","snippet":"void fatal_error(int exitcode, const char *fmt, ...)\n{\n\tchar buf[MAX_MESSAGE];\n\tva_list args;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/read-conf.c","index":-1},"region":{"startLine":118,"endLine":118,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (strcmp(arg, name) == 0) {\n\t\trv = 0;\n\n\t\tif (val != NULL && is_number(*val)) {\n\t\t\tint ii = atoi(val);\n\n\t\t\tif (imax > imin) {\n\t\t\t\t/* have limits, check and enforce them. */\n\t\t\t\tif (ii > imax) {\n\t\t\t\t\tlog_message(LOG_WARNING, \"Warning: number for '%s' too big (%d > imax=%d)\", arg, ii, imax);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/load.c","index":-1},"region":{"startLine":84,"endLine":84,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tavg5 = atoi(ptr);\n\t\tptr = strchr(ptr + 1, ' ');\n\t}\n\n\tif (ptr != NULL) {\n\t\tavg15 = atoi(ptr);\n\t} else {\n\t\tlog_message(LOG_ERR, \"%s does not contain any data (read = %s)\", load_name, buf);\n\t\treturn (ENOLOAD);\n\t}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":70,"endLine":70,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":35,"endLine":35,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (!s)\n\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":187,"endLine":187,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tcase LO_CRYPT_NONE:\n\t\tloopinfo.lo_encrypt_key_size = 0;\n\t\tbreak;\n\tcase LO_CRYPT_XOR:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":187,"lineEnd":187,"columnStart":3,"columnEnd":3,"description":"strncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE)","snippet":"\tcase LO_CRYPT_NONE:\n\t\tloopinfo.lo_encrypt_key_size = 0;\n\t\tbreak;\n\tcase LO_CRYPT_XOR:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":203,"endLine":203,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"{\n\tstruct string_opt_map *m;\n\tint lth;\n\n\tfor (m = &string_opt_map[0]; m->tag; m++) {\n\t\tlth = strlen(m->tag);\n\t\tif (!strncmp(s, m->tag, lth)) {\n\t\t\t*(m->valptr) = xstrdup(s + lth);\n\t\t\treturn 1;\n\t\t}\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":51,"endLine":51,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":376,"endLine":376,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tclose(fd);\n\t}\n\n\t/* save the random seed if a save location exists */\n\t/* don't worry about error messages, we react here anyway */\n\tif (strlen(seedbck) != 0) {\n\t\tint fd_seed;\n\n\t\tif ((fd_seed = open(\"/dev/urandom\", O_RDONLY)) >= 0) {\n\t\t\tint fd_bck;\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":189,"endLine":189,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase LO_CRYPT_XOR:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/iface.c","index":-1},"region":{"startLine":28,"endLine":28,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t}\n\n\t/* read the file line by line */\n\twhile (!feof(file)) {\n\t\tchar line[NETDEV_LINE_LEN];\n\t\tmemset(line, 0, sizeof(line)); /* Just in case. */\n\n\t\tif (fgets(line, NETDEV_LINE_LEN, file) == NULL) {\n\t\t\tif (!ferror(file)) {\n\t\t\t\tbreak;\n\t\t\t} else {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/iface.c","lineStart":28,"lineEnd":28,"columnStart":3,"columnEnd":3,"description":"memset(line, 0, sizeof(line)); /* Just in case. */","snippet":"\t}\n\n\t/* read the file line by line */\n\twhile (!feof(file)) {\n\t\tchar line[NETDEV_LINE_LEN];\n\t\tmemset(line, 0, sizeof(line)); /* Just in case. */\n\n\t\tif (fgets(line, NETDEV_LINE_LEN, file) == NULL) {\n\t\t\tif (!ferror(file)) {\n\t\t\t\tbreak;\n\t\t\t} else {"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/heartbeat.c","index":-1},"region":{"startLine":98,"endLine":98,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t/* Get the seconds since seconds since 00:00:00, Jan 1, 1970 */\n\t\tstrftime(tbuf, TS_SIZE - 1, \"%s\", tm);\n\t\t/* Make it the right width */\n\t\tsprintf(tbufw, \"%*s\\n\", TS_SIZE - 1, tbuf);\n\t\t/* copy it to the buffer */\n\t\tmemcpy(timestamps + (lastts * TS_SIZE), tbufw, TS_SIZE);\n\n\t\t/* success */\n\t\tnext_value();\n\n\t\t/* write the buffer to the file */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/heartbeat.c","lineStart":98,"lineEnd":98,"columnStart":3,"columnEnd":3,"description":"memcpy(timestamps + (lastts * TS_SIZE), tbufw, TS_SIZE)","snippet":"\t\t/* Get the seconds since seconds since 00:00:00, Jan 1, 1970 */\n\t\tstrftime(tbuf, TS_SIZE - 1, \"%s\", tm);\n\t\t/* Make it the right width */\n\t\tsprintf(tbufw, \"%*s\\n\", TS_SIZE - 1, tbuf);\n\t\t/* copy it to the buffer */\n\t\tmemcpy(timestamps + (lastts * TS_SIZE), tbufw, TS_SIZE);\n\n\t\t/* success */\n\t\tnext_value();\n\n\t\t/* write the buffer to the file */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":53,"endLine":53,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"int open_logging(const char *name, int flags)\n{\n\tint rv = 0;\n\n\tif (name != NULL)\n\t\tstrncpy(progname, name, sizeof(progname) - 1);\n\n\terr_count = 0;\n\tusing_terminal = (flags & MSG_TO_STDERR);\n\n\tif (flags & MSG_TO_SYSLOG) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/logmessage.c","lineStart":53,"lineEnd":53,"columnStart":3,"columnEnd":3,"description":"strncpy(progname, name, sizeof(progname) - 1)","snippet":"int open_logging(const char *name, int flags)\n{\n\tint rv = 0;\n\n\tif (name != NULL)\n\t\tstrncpy(progname, name, sizeof(progname) - 1);\n\n\terr_count = 0;\n\tusing_terminal = (flags & MSG_TO_STDERR);\n\n\tif (flags & MSG_TO_SYSLOG) {"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/read-conf.c","index":-1},"region":{"startLine":68,"endLine":68,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tint ii;\n\n\tif (buf == NULL)\n\t\treturn;\n\n\tfor (ii = strlen(buf) - 1; ii >= 0; ii--) {\n\t\tif (is_white(buf[ii])) {\n\t\t\tbuf[ii] = 0;\t/* Replace white space with 'nul'. */\n\t\t} else {\n\t\t\tbreak;\n\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":191,"endLine":191,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tint l;\n\n\tif (!file)\n\t\treturn NULL;\n\n\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)\n\t\tif ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))\n\t\t    && !strncmp(s + 5, file, l)\n\t\t    && (s == opts || s[-1] == ',')"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/pidfile.c","index":-1},"region":{"startLine":46,"endLine":46,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t}\n\t/* Force string to be nul-terminated. */\n\tbuf[n] = 0;\n\n\t/* we only care about integer values */\n\tpid = atoi(buf);\n\n\tif (close(fd) == -1) {\n\t\tint err = errno;\n\t\tlog_message(LOG_ERR, \"could not close %s, errno = %d = '%s'\", file->name, err, strerror(err));\n\t\treturn (err);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":215,"endLine":215,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tfor (act = tlist; act != NULL; act = act->next) {\n\t\t\tstruct pingmode *net = &act->parameter.net; /* 'net' is alias of act->parameter.net */\n\t\t\tstruct sockaddr_in *to_in;\n\n\t\t\t/* setup the socket */\n\t\t\tmemset(&(net->to), 0, sizeof(struct sockaddr));\n\t\t\t/*\n\t\t\t * This pointer is an alias to same memory, an ugly but common\n\t\t\t * method, for example http://www.retran.com/beej/sockaddr_inman.html\n\t\t\t * Also we don't (yet) support IPv6 which needs a bigger structure\n\t\t\t * anyway (e.g. the 'struct sockaddr_storage' type for all) and other"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/net.c","lineStart":215,"lineEnd":215,"columnStart":4,"columnEnd":4,"description":"memset(&(net->to), 0, sizeof(struct sockaddr))","snippet":"\t\tfor (act = tlist; act != NULL; act = act->next) {\n\t\t\tstruct pingmode *net = &act->parameter.net; /* 'net' is alias of act->parameter.net */\n\t\t\tstruct sockaddr_in *to_in;\n\n\t\t\t/* setup the socket */\n\t\t\tmemset(&(net->to), 0, sizeof(struct sockaddr));\n\t\t\t/*\n\t\t\t * This pointer is an alias to same memory, an ugly but common\n\t\t\t * method, for example http://www.retran.com/beej/sockaddr_inman.html\n\t\t\t * Also we don't (yet) support IPv6 which needs a bigger structure\n\t\t\t * anyway (e.g. the 'struct sockaddr_storage' type for all) and other"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":82,"endLine":82,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\treturn (ENOERR);\n\n\tif (count < 1)\n\t\treturn (EINVAL);\n\n\tmemset(outpack, 0, sizeof(outpack));\n\n\t/* set the timeout value */\n\td = ldiv(time, count);\n\ttmax.tv_sec = d.quot;\n\t/* Compute microseconds, including the above remainder. */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/net.c","lineStart":82,"lineEnd":82,"columnStart":2,"columnEnd":2,"description":"memset(outpack, 0, sizeof(outpack))","snippet":"\t\treturn (ENOERR);\n\n\tif (count < 1)\n\t\treturn (EINVAL);\n\n\tmemset(outpack, 0, sizeof(outpack));\n\n\t/* set the timeout value */\n\td = ldiv(time, count);\n\ttmax.tv_sec = d.quot;\n\t/* Compute microseconds, including the above remainder. */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":193,"endLine":193,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":193,"lineEnd":193,"columnStart":3,"columnEnd":3,"description":"strncpy((char *)loopinfo.lo_encrypt_key, pass, 8)","snippet":"\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":123,"endLine":123,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"{\n\tint rv = 0;\n\tchar buf[MAX_MESSAGE];\n\tva_list args;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/logmessage.c","lineStart":123,"lineEnd":123,"columnStart":2,"columnEnd":2,"description":"memset(buf, 0, sizeof(buf))","snippet":"{\n\tint rv = 0;\n\tchar buf[MAX_MESSAGE];\n\tva_list args;\n\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":51,"endLine":51,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":70,"endLine":70,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":70,"endLine":70,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/heartbeat.c","index":-1},"region":{"startLine":60,"endLine":60,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tlastts = 0;\n\t\t\ttimestamps = (char *)xcalloc(hbstamps, TS_SIZE);\n\t\t\t/* read any previous timestamps */\n\t\t\trewind(hb);\n\t\t\twhile (fgets(rbuf, TS_SIZE + 1, hb) != NULL) {\n\t\t\t\tmemcpy(timestamps + (TS_SIZE * lastts), rbuf, TS_SIZE);\n\t\t\t\tnext_value();\n\t\t\t}\n\t\t\t/* Write an indication that the watchdog has started to the heartbeat file */\n\t\t\t/* copy it to the buffer */\n\t\t\tsprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/heartbeat.c","lineStart":60,"lineEnd":60,"columnStart":5,"columnEnd":5,"description":"memcpy(timestamps + (TS_SIZE * lastts), rbuf, TS_SIZE)","snippet":"\t\t\tlastts = 0;\n\t\t\ttimestamps = (char *)xcalloc(hbstamps, TS_SIZE);\n\t\t\t/* read any previous timestamps */\n\t\t\trewind(hb);\n\t\t\twhile (fgets(rbuf, TS_SIZE + 1, hb) != NULL) {\n\t\t\t\tmemcpy(timestamps + (TS_SIZE * lastts), rbuf, TS_SIZE);\n\t\t\t\tnext_value();\n\t\t\t}\n\t\t\t/* Write an indication that the watchdog has started to the heartbeat file */\n\t\t\t/* copy it to the buffer */\n\t\t\tsprintf(rbuf, \"%*s\\n\", TS_SIZE - 1, \"--restart--\");"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":461,"endLine":461,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"{\n\tchar line[100];\n\tstatic char fsname[50];\n\n\twhile (fgets(line, sizeof(line), procfs)) {\n\t\tif (sscanf(line, \"nodev %[^\\n]\\n\", fsname) == 1)\n\t\t\tcontinue;\n\t\tif (sscanf(line, \" %[^ \\n]\\n\", fsname) != 1)\n\t\t\tcontinue;\n\t\treturn fsname;\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":461,"lineEnd":461,"columnStart":7,"columnEnd":7,"description":"if (sscanf(line, \"nodev %[^\\n]\\n\", fsname) == 1)","snippet":"{\n\tchar line[100];\n\tstatic char fsname[50];\n\n\twhile (fgets(line, sizeof(line), procfs)) {\n\t\tif (sscanf(line, \"nodev %[^\\n]\\n\", fsname) == 1)\n\t\t\tcontinue;\n\t\tif (sscanf(line, \" %[^ \\n]\\n\", fsname) != 1)\n\t\t\tcontinue;\n\t\treturn fsname;\n\t}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":46,"endLine":46,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tlog_message(LOG_ALERT, \"out of memory adding test binary\");\n\t\tfree_process();\n\t\treturn (ENOMEM);\n\t}\n\n\tsnprintf(node->proc_name, sizeof(node->proc_name), \"%s\", name);\n\tnode->pid = pid;\n\tnode->time = time(NULL);\n\tnode->ecode = 0;\n\tnode->is_done = FALSE;\n\tnode->next = process_head;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/test_binary.c","lineStart":46,"lineEnd":46,"columnStart":2,"columnEnd":2,"description":"snprintf(node->proc_name, sizeof(node->proc_name), \"%s\", name)","snippet":"\t\tlog_message(LOG_ALERT, \"out of memory adding test binary\");\n\t\tfree_process();\n\t\treturn (ENOMEM);\n\t}\n\n\tsnprintf(node->proc_name, sizeof(node->proc_name), \"%s\", name);\n\tnode->pid = pid;\n\tnode->time = time(NULL);\n\tnode->ecode = 0;\n\tnode->is_done = FALSE;\n\tnode->next = process_head;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":51,"endLine":51,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":948,"endLine":948,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tfor (i = 0; envp0[i] != NULL; i++)\n\t\tenviron[i] = xstrdup(envp0[i]);\n\tenviron[i] = NULL;\n\n\tif (i > 0)\n\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":154,"endLine":154,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (types == NULL)\n\t\treturn 1;\n\n\tif ((notype = alloca(strlen(type) + 3)) == NULL)\n\t\tdie(EX_SYSERR, \"mount: out of memory\");\n\tsprintf(notype, \"no%s\", type);\n\n\tfoundyes = foundno = no = 0;\n\twhile (types != NULL) {\n\t\tif (cdr(types) == NULL)\n\t\t\tno = (car(types)[0] == 'n') && (car(types)[1] == 'o');"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":154,"lineEnd":154,"columnStart":2,"columnEnd":2,"description":"sprintf(notype, \"no%s\", type)","snippet":"\tif (types == NULL)\n\t\treturn 1;\n\n\tif ((notype = alloca(strlen(type) + 3)) == NULL)\n\t\tdie(EX_SYSERR, \"mount: out of memory\");\n\tsprintf(notype, \"no%s\", type);\n\n\tfoundyes = foundno = no = 0;\n\twhile (types != NULL) {\n\t\tif (cdr(types) == NULL)\n\t\t\tno = (car(types)[0] == 'n') && (car(types)[1] == 'o');"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":70,"endLine":70,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":173,"endLine":173,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tperror(device);\n\t\treturn 1;\n\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));\n\tstrncpy(loopinfo.lo_name, file, LO_NAME_SIZE);\n\tloopinfo.lo_name[LO_NAME_SIZE - 1] = 0;\n\tif (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))\n\t    < 0) {\n\t\tfprintf(stderr, \"Unsupported encryption type %s\\n\", encryption);\n\t\treturn 1;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":173,"lineEnd":173,"columnStart":2,"columnEnd":2,"description":"strncpy(loopinfo.lo_name, file, LO_NAME_SIZE)","snippet":"\t\tperror(device);\n\t\treturn 1;\n\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));\n\tstrncpy(loopinfo.lo_name, file, LO_NAME_SIZE);\n\tloopinfo.lo_name[LO_NAME_SIZE - 1] = 0;\n\tif (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))\n\t    < 0) {\n\t\tfprintf(stderr, \"Unsupported encryption type %s\\n\", encryption);\n\t\treturn 1;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/file_stat.c","index":-1},"region":{"startLine":37,"endLine":37,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t}\n\t\t/* do verbose logging */\n\t\tif (verbose && logtick && ticker == 1) {\n\t\t\tchar text[25];\n\t\t\t/* Remove the trailing '\\n' of the ctime() formatted string. */\n\t\t\tstrncpy(text, ctime(&buf.st_mtime), sizeof(text)-1);\n\t\t\ttext[sizeof(text)-1] = 0;\n\t\t\tlog_message(LOG_DEBUG, \"file %s was last changed at %s (%ds ago)\", file->name, text, twait);\n\t\t}\n\t} else {\n\t\t/* do verbose logging */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/file_stat.c","lineStart":37,"lineEnd":37,"columnStart":4,"columnEnd":4,"description":"strncpy(text, ctime(&buf.st_mtime), sizeof(text)-1)","snippet":"\t\t}\n\t\t/* do verbose logging */\n\t\tif (verbose && logtick && ticker == 1) {\n\t\t\tchar text[25];\n\t\t\t/* Remove the trailing '\\n' of the ctime() formatted string. */\n\t\t\tstrncpy(text, ctime(&buf.st_mtime), sizeof(text)-1);\n\t\t\ttext[sizeof(text)-1] = 0;\n\t\t\tlog_message(LOG_DEBUG, \"file %s was last changed at %s (%ds ago)\", file->name, text, twait);\n\t\t}\n\t} else {\n\t\t/* do verbose logging */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":151,"endLine":151,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else\n\tvsprintf(buf, fmt, args);\n#endif\n\tva_end(args);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/logmessage.c","lineStart":151,"lineEnd":151,"columnStart":2,"columnEnd":2,"description":"vsnprintf(buf, sizeof(buf) - 1, fmt, args)","snippet":"\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else\n\tvsprintf(buf, fmt, args);\n#endif\n\tva_end(args);\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":278,"endLine":278,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t*extra_opts = NULL;\n\n\tclear_string_opts();\n\n\tif (opts != NULL) {\n\t\t*extra_opts = xmalloc(strlen(opts) + 1);\n\t\t**extra_opts = '\\0';\n\n\t\tfor (opt = strtok(opts, \",\"); opt; opt = strtok(NULL, \",\"))\n\t\t\tif (!parse_string_opt(opt))\n\t\t\t\tparse_opt(opt, flags, *extra_opts);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/iface.c","index":-1},"region":{"startLine":43,"endLine":43,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t}\n\t\t} else {\n\t\t\tint i = 0;\n\n\t\t\tfor (; line[i] == ' ' || line[i] == '\\t'; i++) ;\n\t\t\tif (strncmp(line + i, dev->name, strlen(dev->name)) == 0) {\n\t\t\t\tunsigned long bytes = strtoul(line + i + strlen(dev->name) + 1, NULL, 10);\n\n\t\t\t\t/* do verbose logging */\n\t\t\t\tif (verbose && logtick && ticker == 1)\n\t\t\t\t\tlog_message(LOG_DEBUG, \"device %s received %lu bytes\", dev->name, bytes);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lock_mem.c","index":-1},"region":{"startLine":57,"endLine":57,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t/* lock all actual and future pages into memory */\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {\n\t\t\tlog_message(LOG_ERR, \"cannot lock realtime memory (errno = %d = '%s')\", errno, strerror(errno));\n\t\t} else {\n\t\t\tstruct sched_param sp;\n\t\t\tmemset(&sp, 0, sizeof(sp));\n\t\t\t/* now set the scheduler */\n\t\t\tsp.sched_priority = priority;\n\t\t\tif (sched_setscheduler(0, SCHED_RR, &sp) != 0) {\n\t\t\t\tlog_message(LOG_ERR, \"cannot set scheduler (errno = %d = '%s')\", errno, strerror(errno));\n\t\t\t} else"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lock_mem.c","lineStart":57,"lineEnd":57,"columnStart":4,"columnEnd":4,"description":"memset(&sp, 0, sizeof(sp))","snippet":"\t\t/* lock all actual and future pages into memory */\n\t\tif (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {\n\t\t\tlog_message(LOG_ERR, \"cannot lock realtime memory (errno = %d = '%s')\", errno, strerror(errno));\n\t\t} else {\n\t\t\tstruct sched_param sp;\n\t\t\tmemset(&sp, 0, sizeof(sp));\n\t\t\t/* now set the scheduler */\n\t\t\tsp.sched_priority = priority;\n\t\t\tif (sched_setscheduler(0, SCHED_RR, &sp) != 0) {\n\t\t\t\tlog_message(LOG_ERR, \"cannot set scheduler (errno = %d = '%s')\", errno, strerror(errno));\n\t\t\t} else"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/load.c","index":-1},"region":{"startLine":73,"endLine":73,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\treturn (err);\n\t}\n\t/* Force string to be nul-terminated. */\n\tbuf[n] = 0;\n\t/* we only care about integer values */\n\tavg1 = atoi(buf);\n\n\t/* if we have incorrect data we might not be able to find */\n\t/* the blanks we're looking for */\n\tptr = strchr(buf, ' ');\n\tif (ptr != NULL) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":187,"endLine":187,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\t/* Walk through the directory. */\n\twhile ((d = readdir(dir)) != NULL) {\n\n\t\t/* See if this is a process */\n\t\tif ((act_pid = atoi(d->d_name)) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Get a PROC struct. If this fails, which is likely if we have an\n\t\t * out-of-memory error, we return gracefully with what we have managed"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":953,"endLine":953,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);\n\t\targv0[1] = NULL;\n\t}\n#endif\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":953,"lineEnd":953,"columnStart":3,"columnEnd":3,"description":"strncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1)","snippet":"\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);\n\t\targv0[1] = NULL;\n\t}\n#endif\n}\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mntent.c","index":-1},"region":{"startLine":195,"endLine":195,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (*s && !is_space_or_tab(*s))\n\t\tgoto err;\n\n\ts = skip_spaces(s);\n\tif (isdigit(*s)) {\n\t\tme.mnt_passno = atoi(s);\n\t\twhile (isdigit(*s))\n\t\t\ts++;\n\t} else\n\t\tme.mnt_passno = 0;\n\tif (*s && !is_space_or_tab(*s))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":35,"endLine":35,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (!s)\n\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":464,"endLine":464,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\topen_netcheck(target_list);\n\t}\n\n\t/* allocate some memory to store a filename, this is needed later on even\n\t * if the system runs out of memory */\n\tfilename_buf = (char *)xcalloc(strlen(logdir) + sizeof(\"/repair-bin.stdout\") + 1, sizeof(char));\n\n\tif (!foreground) {\n\t\tif (wd_daemon(0, 0)) {\n\t\t\tfatal_error(EX_SYSERR, \"failed to daemonize (%s)\", strerror(errno));\n\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/heartbeat.c","index":-1},"region":{"startLine":96,"endLine":96,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (timenow != -1) {\n\t\ttm = gmtime(&timenow);\n\t\t/* Get the seconds since seconds since 00:00:00, Jan 1, 1970 */\n\t\tstrftime(tbuf, TS_SIZE - 1, \"%s\", tm);\n\t\t/* Make it the right width */\n\t\tsprintf(tbufw, \"%*s\\n\", TS_SIZE - 1, tbuf);\n\t\t/* copy it to the buffer */\n\t\tmemcpy(timestamps + (lastts * TS_SIZE), tbufw, TS_SIZE);\n\n\t\t/* success */\n\t\tnext_value();"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/heartbeat.c","lineStart":96,"lineEnd":96,"columnStart":3,"columnEnd":3,"description":"sprintf(tbufw, \"%*s\\n\", TS_SIZE - 1, tbuf)","snippet":"\tif (timenow != -1) {\n\t\ttm = gmtime(&timenow);\n\t\t/* Get the seconds since seconds since 00:00:00, Jan 1, 1970 */\n\t\tstrftime(tbuf, TS_SIZE - 1, \"%s\", tm);\n\t\t/* Make it the right width */\n\t\tsprintf(tbufw, \"%*s\\n\", TS_SIZE - 1, tbuf);\n\t\t/* copy it to the buffer */\n\t\tmemcpy(timestamps + (lastts * TS_SIZE), tbufw, TS_SIZE);\n\n\t\t/* success */\n\t\tnext_value();"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":152,"endLine":152,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (streq(type, MNTTYPE_SWAP))\n\t\treturn 0;\n\tif (types == NULL)\n\t\treturn 1;\n\n\tif ((notype = alloca(strlen(type) + 3)) == NULL)\n\t\tdie(EX_SYSERR, \"mount: out of memory\");\n\tsprintf(notype, \"no%s\", type);\n\n\tfoundyes = foundno = no = 0;\n\twhile (types != NULL) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":700,"endLine":700,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tif (strlen(type) < 100)\n#endif\n\t\t{\n\t\t\tchar mountprog[120];\n\n\t\t\tsprintf(mountprog, \"/sbin/mount.%s\", type);\n\t\t\tif (stat(mountprog, &statbuf) == 0) {\n\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":700,"lineEnd":700,"columnStart":4,"columnEnd":4,"description":"sprintf(mountprog, \"/sbin/mount.%s\", type)","snippet":"\t\tif (strlen(type) < 100)\n#endif\n\t\t{\n\t\t\tchar mountprog[120];\n\n\t\t\tsprintf(mountprog, \"/sbin/mount.%s\", type);\n\t\t\tif (stat(mountprog, &statbuf) == 0) {\n\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":950,"endLine":950,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tenviron[i] = NULL;\n\n\tif (i > 0)\n\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);\n\t\targv0[1] = NULL;\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":463,"endLine":463,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tstatic char fsname[50];\n\n\twhile (fgets(line, sizeof(line), procfs)) {\n\t\tif (sscanf(line, \"nodev %[^\\n]\\n\", fsname) == 1)\n\t\t\tcontinue;\n\t\tif (sscanf(line, \" %[^ \\n]\\n\", fsname) != 1)\n\t\t\tcontinue;\n\t\treturn fsname;\n\t}\n\treturn 0;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":463,"lineEnd":463,"columnStart":7,"columnEnd":7,"description":"if (sscanf(line, \" %[^ \\n]\\n\", fsname) != 1)","snippet":"\tstatic char fsname[50];\n\n\twhile (fgets(line, sizeof(line), procfs)) {\n\t\tif (sscanf(line, \"nodev %[^\\n]\\n\", fsname) == 1)\n\t\t\tcontinue;\n\t\tif (sscanf(line, \" %[^ \\n]\\n\", fsname) != 1)\n\t\t\tcontinue;\n\t\treturn fsname;\n\t}\n\treturn 0;\n}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/load.c","index":-1},"region":{"startLine":79,"endLine":79,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\t/* if we have incorrect data we might not be able to find */\n\t/* the blanks we're looking for */\n\tptr = strchr(buf, ' ');\n\tif (ptr != NULL) {\n\t\tavg5 = atoi(ptr);\n\t\tptr = strchr(ptr + 1, ' ');\n\t}\n\n\tif (ptr != NULL) {\n\t\tavg15 = atoi(ptr);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/xmalloc.c","index":-1},"region":{"startLine":58,"endLine":58,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (s == NULL)\n\t\treturn NULL;\n\n\tt = strdup(s);\n\tif (t == NULL)\n\t\tfatal_error(EX_SYSERR, \"xstrdup failed for %lu byte string\", (unsigned long)strlen(s));\n\n\treturn t;\n}\n\nchar *xstrndup(const char *s, int n)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/memory.c","index":-1},"region":{"startLine":101,"endLine":101,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\treturn (EINVMEM);\n\t}\n\n\t/* we only care about integer values */\n\tfreemem  = atoi(ptr1 + strlen(FREEMEM));\n\tfreeswap = atoi(ptr2 + strlen(FREESWAP));\n\tfree = freemem + freeswap;\n\n\tif (verbose && logtick && ticker == 1)\n\t\tlog_message(LOG_DEBUG, \"currently there are %u + %u kB of free memory+swap available\", freemem, freeswap);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/wd_keepalive.c","index":-1},"region":{"startLine":122,"endLine":122,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase 'b':\n\t\tcase 'q':\n\t\tcase 'v':\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tcount_max = atol(optarg);\n\t\t\tlog_message(LOG_WARNING, \"NOTE: Using --loop-exit so daemon will exit after %ld time intervals\",\n\t\t\t\t    count_max);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(progname);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mntent.c","index":-1},"region":{"startLine":31,"endLine":31,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tint n;\n\n\tif(s == NULL)\n\t\treturn xstrdup(\"none\");\n\n\tn = (int)strlen(s);\n\tss = sp = xmalloc(4 * n + 1);\n\twhile (1) {\n\t\tfor (n = 0; n < sizeof(need_escaping); n++) {\n\t\t\tif (*s == need_escaping[n]) {\n\t\t\t\t*sp++ = '\\\\';"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":197,"endLine":197,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"int open_netcheck(struct list *tlist)\n{\n\tstruct list *act;\n\tint hold;\n\tstruct icmp_filter filt;\n\tmemset(&filt, 0, sizeof(filt));\n\tfilt.data = ~(1<<ICMP_ECHOREPLY);\n\n\tif (tlist != NULL) {\n\t\t/* Have at least on ping target to configure, get ICMP settings. */\n\t\tstruct protoent *proto;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/net.c","lineStart":197,"lineEnd":197,"columnStart":2,"columnEnd":2,"description":"memset(&filt, 0, sizeof(filt))","snippet":"int open_netcheck(struct list *tlist)\n{\n\tstruct list *act;\n\tint hold;\n\tstruct icmp_filter filt;\n\tmemset(&filt, 0, sizeof(filt));\n\tfilt.data = ~(1<<ICMP_ECHOREPLY);\n\n\tif (tlist != NULL) {\n\t\t/* Have at least on ping target to configure, get ICMP settings. */\n\t\tstruct protoent *proto;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":101,"endLine":101,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tstruct stat statbuf;\n\tstruct loop_info loopinfo;\n\tFILE *procdev;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tsprintf(dev, \"/dev/loop%d\", i);\n\t\tif (stat(dev, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)) {\n\t\t\tsomedev++;\n\t\t\tfd = open(dev, O_RDONLY);\n\t\t\tif (fd >= 0) {\n\t\t\t\tif (ioctl(fd, LOOP_GET_STATUS, &loopinfo) == 0)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":101,"lineEnd":101,"columnStart":3,"columnEnd":3,"description":"sprintf(dev, \"/dev/loop%d\", i)","snippet":"\tstruct stat statbuf;\n\tstruct loop_info loopinfo;\n\tFILE *procdev;\n\n\tfor (i = 0; i < 256; i++) {\n\t\tsprintf(dev, \"/dev/loop%d\", i);\n\t\tif (stat(dev, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)) {\n\t\t\tsomedev++;\n\t\t\tfd = open(dev, O_RDONLY);\n\t\t\tif (fd >= 0) {\n\t\t\t\tif (ioctl(fd, LOOP_GET_STATUS, &loopinfo) == 0)"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/memory.c","index":-1},"region":{"startLine":100,"endLine":100,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tlog_message(LOG_ERR, \"%s contains invalid data (read = %s)\", mem_name, buf);\n\t\treturn (EINVMEM);\n\t}\n\n\t/* we only care about integer values */\n\tfreemem  = atoi(ptr1 + strlen(FREEMEM));\n\tfreeswap = atoi(ptr2 + strlen(FREESWAP));\n\tfree = freemem + freeswap;\n\n\tif (verbose && logtick && ticker == 1)\n\t\tlog_message(LOG_DEBUG, \"currently there are %u + %u kB of free memory+swap available\", freemem, freeswap);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/daemon-pid.c","index":-1},"region":{"startLine":44,"endLine":44,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tint pid = 0;\n\tFILE *fp = fopen(fname, \"r\");\n\n\tif (fp != NULL) {\n\t\t/* File exists, read its contents. */\n\t\tif (fscanf(fp, \" %d\", &pid) != 1) {\n\t\t\tpid = 0;\n\t\t}\n\n\t\tfclose(fp);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/daemon-pid.c","lineStart":44,"lineEnd":44,"columnStart":7,"columnEnd":7,"description":"if (fscanf(fp, \" %d\", &pid) != 1)","snippet":"\tint pid = 0;\n\tFILE *fp = fopen(fname, \"r\");\n\n\tif (fp != NULL) {\n\t\t/* File exists, read its contents. */\n\t\tif (fscanf(fp, \" %d\", &pid) != 1) {\n\t\t\tpid = 0;\n\t\t}\n\n\t\tfclose(fp);\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/memory.c","index":-1},"region":{"startLine":100,"endLine":100,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tlog_message(LOG_ERR, \"%s contains invalid data (read = %s)\", mem_name, buf);\n\t\treturn (EINVMEM);\n\t}\n\n\t/* we only care about integer values */\n\tfreemem  = atoi(ptr1 + strlen(FREEMEM));\n\tfreeswap = atoi(ptr2 + strlen(FREESWAP));\n\tfree = freemem + freeswap;\n\n\tif (verbose && logtick && ticker == 1)\n\t\tlog_message(LOG_DEBUG, \"currently there are %u + %u kB of free memory+swap available\", freemem, freeswap);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_INSECURE_API_STR","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Insecure string API","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":264,"endLine":264,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tchild_pid = fork();\n\tif (!child_pid) {\n\n\t\t/* Don't want the stdout and stderr of our test program\n\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":73,"endLine":73,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}\n\n/* Call this with SIG_BLOCK to block and SIG_UNBLOCK to unblock.  */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":73,"lineEnd":73,"columnStart":2,"columnEnd":2,"description":"strcat(res, u)","snippet":"\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}\n\n/* Call this with SIG_BLOCK to block and SIG_UNBLOCK to unblock.  */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":37,"endLine":37,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n\nchar *xstrconcat3(const char *s, const char *t, const char *u)\n{"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":37,"lineEnd":37,"columnStart":2,"columnEnd":2,"description":"strcat(res, t)","snippet":"\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n\nchar *xstrconcat3(const char *s, const char *t, const char *u)\n{"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":54,"endLine":54,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n\nchar *xstrconcat4(const char *s, const char *t, const char *u, const char *v)\n{"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":54,"lineEnd":54,"columnStart":2,"columnEnd":2,"description":"strcat(res, u)","snippet":"\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n\nchar *xstrconcat4(const char *s, const char *t, const char *u, const char *v)\n{"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":52,"endLine":52,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!t)\n\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":74,"endLine":74,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}\n\n/* Call this with SIG_BLOCK to block and SIG_UNBLOCK to unblock.  */\nvoid block_signals(int how)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":74,"lineEnd":74,"columnStart":2,"columnEnd":2,"description":"strcat(res, v)","snippet":"\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}\n\n/* Call this with SIG_BLOCK to block and SIG_UNBLOCK to unblock.  */\nvoid block_signals(int how)"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":52,"endLine":52,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!t)\n\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":52,"lineEnd":52,"columnStart":2,"columnEnd":2,"description":"strcpy(res, s)","snippet":"\tif (!t)\n\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":907,"endLine":907,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\topts = opts0;\n\t\t\t\t\ttype = type0;\n\t\t\t\t}\n\t\t\t\tif (opts) {\n\t\t\t\t\topts = realloc(xstrdup(opts), strlen(opts) + 4);\n\t\t\t\t\tstrcat(opts, \",ro\");\n\t\t\t\t} else\n\t\t\t\t\topts = \"ro\";\n\t\t\t\tif (type && !strcmp(type, \"guess\"))\n\t\t\t\t\ttype = 0;\n\t\t\t\terror(\"mount: %s%s is write-protected, mounting read-only\","}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":907,"lineEnd":907,"columnStart":6,"columnEnd":6,"description":"strcat(opts, \",ro\")","snippet":"\t\t\t\t\topts = opts0;\n\t\t\t\t\ttype = type0;\n\t\t\t\t}\n\t\t\t\tif (opts) {\n\t\t\t\t\topts = realloc(xstrdup(opts), strlen(opts) + 4);\n\t\t\t\t\tstrcat(opts, \",ro\");\n\t\t\t\t} else\n\t\t\t\t\topts = \"ro\";\n\t\t\t\tif (type && !strcmp(type, \"guess\"))\n\t\t\t\t\ttype = 0;\n\t\t\t\terror(\"mount: %s%s is write-protected, mounting read-only\","}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":36,"endLine":36,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!s)\n\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n\nchar *xstrconcat3(const char *s, const char *t, const char *u)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":36,"lineEnd":36,"columnStart":2,"columnEnd":2,"description":"strcpy(res, s)","snippet":"\tif (!s)\n\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n\nchar *xstrconcat3(const char *s, const char *t, const char *u)"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":53,"endLine":53,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n\nchar *xstrconcat4(const char *s, const char *t, const char *u, const char *v)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":53,"lineEnd":53,"columnStart":2,"columnEnd":2,"description":"strcat(res, t)","snippet":"\t\tt = \"\";\n\tif (!u)\n\t\tu = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\treturn res;\n}\n\nchar *xstrconcat4(const char *s, const char *t, const char *u, const char *v)"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":268,"endLine":268,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":87,"endLine":87,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tchild_pid = fork();\n\tif (!child_pid) {\n\t\t/* Don't want the stdin and stdout of our repair program\n\t\t * to cause trouble.\n\t\t * So make stdout and stderr go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/repair-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/repair-bin.stderr\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":263,"endLine":263,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"#endif\n\t\t\treturn;\n\t\t}\n\tif (*extra_opts)\n\t\tstrcat(extra_opts, \",\");\n\tstrcat(extra_opts, opt);\n}\n\n/* Take -o options list and compute 4th and 5th args to mount(2).  flags\n   gets the standard options and extra_opts anything we don't recognize.  */\nstatic void parse_opts(char *opts, int *flags, char **extra_opts)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":263,"lineEnd":263,"columnStart":2,"columnEnd":2,"description":"strcat(extra_opts, opt)","snippet":"#endif\n\t\t\treturn;\n\t\t}\n\tif (*extra_opts)\n\t\tstrcat(extra_opts, \",\");\n\tstrcat(extra_opts, opt);\n}\n\n/* Take -o options list and compute 4th and 5th args to mount(2).  flags\n   gets the standard options and extra_opts anything we don't recognize.  */\nstatic void parse_opts(char *opts, int *flags, char **extra_opts)"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":365,"endLine":365,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tmemset(&wtmp, 0, sizeof(wtmp));\n\n\t\ttime(&t);\n\t\tstrcpy(wtmp.ut_user, \"shutdown\");\n\t\tstrcpy(wtmp.ut_line, \"~\");\n\t\tstrcpy(wtmp.ut_id, \"~~\");\n\t\twtmp.ut_pid = 0;\n\t\twtmp.ut_type = RUN_LVL;\n\t\twtmp.ut_time = t;\n\t\tif (write(fd, (char *)&wtmp, sizeof(wtmp)) < 0)\n\t\t\tlog_message(LOG_ERR, \"failed writing wtmp (%s)\", strerror(errno));"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":268,"endLine":268,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/test_binary.c","lineStart":268,"lineEnd":268,"columnStart":3,"columnEnd":3,"description":"strcpy(filename_buf, logdir)","snippet":"\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":269,"endLine":269,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */\n\t\tif (version == 0) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/test_binary.c","lineStart":269,"lineEnd":269,"columnStart":3,"columnEnd":3,"description":"strcat(filename_buf, \"/test-bin.stderr\")","snippet":"\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */\n\t\tif (version == 0) {"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":91,"endLine":91,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t * So make stdout and stderr go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/repair-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/repair-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":36,"endLine":36,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!s)\n\t\ts = \"\";\n\tif (!t)\n\t\tt = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\treturn res;\n}\n\nchar *xstrconcat3(const char *s, const char *t, const char *u)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":364,"endLine":364,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tstruct utmp wtmp;\n\t\tmemset(&wtmp, 0, sizeof(wtmp));\n\n\t\ttime(&t);\n\t\tstrcpy(wtmp.ut_user, \"shutdown\");\n\t\tstrcpy(wtmp.ut_line, \"~\");\n\t\tstrcpy(wtmp.ut_id, \"~~\");\n\t\twtmp.ut_pid = 0;\n\t\twtmp.ut_type = RUN_LVL;\n\t\twtmp.ut_time = t;\n\t\tif (write(fd, (char *)&wtmp, sizeof(wtmp)) < 0)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":952,"endLine":952,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (i > 0)\n\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);\n\t\targv0[1] = NULL;\n\t}\n#endif\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":363,"endLine":363,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\ttime_t t;\n\t\tstruct utmp wtmp;\n\t\tmemset(&wtmp, 0, sizeof(wtmp));\n\n\t\ttime(&t);\n\t\tstrcpy(wtmp.ut_user, \"shutdown\");\n\t\tstrcpy(wtmp.ut_line, \"~\");\n\t\tstrcpy(wtmp.ut_id, \"~~\");\n\t\twtmp.ut_pid = 0;\n\t\twtmp.ut_type = RUN_LVL;\n\t\twtmp.ut_time = t;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":72,"endLine":72,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":72,"lineEnd":72,"columnStart":2,"columnEnd":2,"description":"strcat(res, t)","snippet":"\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":952,"endLine":952,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (i > 0)\n\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);\n\t\targv0[1] = NULL;\n\t}\n#endif\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":952,"lineEnd":952,"columnStart":3,"columnEnd":3,"description":"strcpy(argv0[0], PROC_NAME)","snippet":"\tif (i > 0)\n\t\tl = envp0[i - 1] + strlen(envp0[i - 1]) - argv0[0];\n\telse\n\t\tl = argv0[argc0 - 1] + strlen(argv0[argc0 - 1]) - argv0[0];\n\tif (l > sizeof(PROC_NAME)) {\n\t\tstrcpy(argv0[0], PROC_NAME);\n\t\tstrncpy(argv0[0] + sizeof(PROC_NAME) - 1, spec, l - sizeof(PROC_NAME) - 1);\n\t\targv0[1] = NULL;\n\t}\n#endif\n}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":71,"endLine":71,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":264,"endLine":264,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tchild_pid = fork();\n\tif (!child_pid) {\n\n\t\t/* Don't want the stdout and stderr of our test program\n\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/test_binary.c","lineStart":264,"lineEnd":264,"columnStart":3,"columnEnd":3,"description":"strcpy(filename_buf, logdir)","snippet":"\tchild_pid = fork();\n\tif (!child_pid) {\n\n\t\t/* Don't want the stdout and stderr of our test program\n\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":262,"endLine":262,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t}\n#endif\n\t\t\treturn;\n\t\t}\n\tif (*extra_opts)\n\t\tstrcat(extra_opts, \",\");\n\tstrcat(extra_opts, opt);\n}\n\n/* Take -o options list and compute 4th and 5th args to mount(2).  flags\n   gets the standard options and extra_opts anything we don't recognize.  */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":262,"lineEnd":262,"columnStart":3,"columnEnd":3,"description":"strcat(extra_opts, \",\")","snippet":"\t\t\t}\n#endif\n\t\t\treturn;\n\t\t}\n\tif (*extra_opts)\n\t\tstrcat(extra_opts, \",\");\n\tstrcat(extra_opts, opt);\n}\n\n/* Take -o options list and compute 4th and 5th args to mount(2).  flags\n   gets the standard options and extra_opts anything we don't recognize.  */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":71,"endLine":71,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/sundries.c","lineStart":71,"lineEnd":71,"columnStart":2,"columnEnd":2,"description":"strcpy(res, s)","snippet":"\tif (!u)\n\t\tu = \"\";\n\tif (!v)\n\t\tv = \"\";\n\tres = xmalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1);\n\tstrcpy(res, s);\n\tstrcat(res, t);\n\tstrcat(res, u);\n\tstrcat(res, v);\n\treturn res;\n}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":265,"endLine":265,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (!child_pid) {\n\n\t\t/* Don't want the stdout and stderr of our test program\n\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/test_binary.c","lineStart":265,"lineEnd":265,"columnStart":3,"columnEnd":3,"description":"strcat(filename_buf, \"/test-bin.stdout\")","snippet":"\tif (!child_pid) {\n\n\t\t/* Don't want the stdout and stderr of our test program\n\t\t * to cause trouble, so make them go to their respective files */\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stdout\");\n\t\tif (!freopen(filename_buf, \"a+\", stdout))\n\t\t\texit(errno);\n\t\tstrcpy(filename_buf, logdir);\n\t\tstrcat(filename_buf, \"/test-bin.stderr\");\n\t\tif (!freopen(filename_buf, \"a+\", stderr))"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_ARRAY_INDEX_TAINTED","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Array index tainted","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":200,"endLine":200,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Non-hex digit '%c'.\\n\", pass[i]);\n\t\t\t\treturn 1;\n\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":200,"lineEnd":200,"columnStart":14,"columnEnd":14,"description":"islower(pass[i])","snippet":"\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Non-hex digit '%c'.\\n\", pass[i]);\n\t\t\t\treturn 1;\n\t\t\t}"},{"position":1,"source":"src/lomount.c","lineStart":199,"lineEnd":199,"columnStart":34,"columnEnd":44,"description":"pass[i] > '9'","snippet":"\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Non-hex digit '%c'.\\n\", pass[i]);\n\t\t\t\treturn 1;"},{"position":2,"source":"src/lomount.c","lineStart":198,"lineEnd":198,"columnStart":8,"columnEnd":8,"description":"isxdigit(pass[i])","snippet":"\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Non-hex digit '%c'.\\n\", pass[i]);"},{"position":3,"source":"src/lomount.c","lineStart":196,"lineEnd":196,"columnStart":10,"columnEnd":10,"description":"pass = getpass(\"Init (up to 16 hex digits): \")","snippet":"\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;"},{"position":4,"source":"src/lomount.c","lineStart":175,"lineEnd":175,"columnStart":6,"columnEnd":6,"description":"if (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))","snippet":"\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));\n\tstrncpy(loopinfo.lo_name, file, LO_NAME_SIZE);\n\tloopinfo.lo_name[LO_NAME_SIZE - 1] = 0;\n\tif (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))\n\t    < 0) {\n\t\tfprintf(stderr, \"Unsupported encryption type %s\\n\", encryption);\n\t\treturn 1;\n\t}\n\tloopinfo.lo_offset = offset;"},{"position":5,"source":"src/lomount.c","lineStart":167,"lineEnd":167,"columnStart":6,"columnEnd":34,"description":"(fd = open(device, mode)) < 0","snippet":"\t\tif (ffd < 0) {\n\t\t\tperror(file);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((fd = open(device, mode)) < 0) {\n\t\tperror(device);\n\t\treturn 1;\n\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));"},{"position":6,"source":"src/lomount.c","lineStart":159,"lineEnd":159,"columnStart":6,"columnEnd":33,"description":"(ffd = open(file, mode)) < 0","snippet":"\tstruct loop_info loopinfo;\n\tint fd, ffd, mode, i;\n\tchar *pass;\n\n\tmode = (*loopro ? O_RDONLY : O_RDWR);\n\tif ((ffd = open(file, mode)) < 0) {\n\t\tif (!*loopro && errno == EROFS)\n\t\t\tffd = open(file, mode = O_RDONLY);\n\t\tif (ffd < 0) {\n\t\t\tperror(file);\n\t\t\treturn 1;"},{"position":7,"source":"src/lomount.c","lineStart":158,"lineEnd":158,"columnStart":10,"columnEnd":11,"description":"*loopro","snippet":"{\n\tstruct loop_info loopinfo;\n\tint fd, ffd, mode, i;\n\tchar *pass;\n\n\tmode = (*loopro ? O_RDONLY : O_RDWR);\n\tif ((ffd = open(file, mode)) < 0) {\n\t\tif (!*loopro && errno == EROFS)\n\t\t\tffd = open(file, mode = O_RDONLY);\n\t\tif (ffd < 0) {\n\t\t\tperror(file);"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":198,"endLine":198,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Non-hex digit '%c'.\\n\", pass[i]);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/lomount.c","lineStart":198,"lineEnd":198,"columnStart":8,"columnEnd":8,"description":"isxdigit(pass[i])","snippet":"\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;\n\t\t\telse {\n\t\t\t\tfprintf(stderr, \"Non-hex digit '%c'.\\n\", pass[i]);"},{"position":1,"source":"src/lomount.c","lineStart":196,"lineEnd":196,"columnStart":10,"columnEnd":10,"description":"pass = getpass(\"Init (up to 16 hex digits): \")","snippet":"\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;"},{"position":2,"source":"src/lomount.c","lineStart":175,"lineEnd":175,"columnStart":6,"columnEnd":6,"description":"if (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))","snippet":"\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));\n\tstrncpy(loopinfo.lo_name, file, LO_NAME_SIZE);\n\tloopinfo.lo_name[LO_NAME_SIZE - 1] = 0;\n\tif (encryption && (loopinfo.lo_encrypt_type = crypt_type(encryption))\n\t    < 0) {\n\t\tfprintf(stderr, \"Unsupported encryption type %s\\n\", encryption);\n\t\treturn 1;\n\t}\n\tloopinfo.lo_offset = offset;"},{"position":3,"source":"src/lomount.c","lineStart":167,"lineEnd":167,"columnStart":6,"columnEnd":34,"description":"(fd = open(device, mode)) < 0","snippet":"\t\tif (ffd < 0) {\n\t\t\tperror(file);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((fd = open(device, mode)) < 0) {\n\t\tperror(device);\n\t\treturn 1;\n\t}\n\t*loopro = (mode == O_RDONLY);\n\tmemset(&loopinfo, 0, sizeof(loopinfo));"},{"position":4,"source":"src/lomount.c","lineStart":159,"lineEnd":159,"columnStart":6,"columnEnd":33,"description":"(ffd = open(file, mode)) < 0","snippet":"\tstruct loop_info loopinfo;\n\tint fd, ffd, mode, i;\n\tchar *pass;\n\n\tmode = (*loopro ? O_RDONLY : O_RDWR);\n\tif ((ffd = open(file, mode)) < 0) {\n\t\tif (!*loopro && errno == EROFS)\n\t\t\tffd = open(file, mode = O_RDONLY);\n\t\tif (ffd < 0) {\n\t\t\tperror(file);\n\t\t\treturn 1;"},{"position":5,"source":"src/lomount.c","lineStart":158,"lineEnd":158,"columnStart":10,"columnEnd":11,"description":"*loopro","snippet":"{\n\tstruct loop_info loopinfo;\n\tint fd, ffd, mode, i;\n\tchar *pass;\n\n\tmode = (*loopro ? O_RDONLY : O_RDWR);\n\tif ((ffd = open(file, mode)) < 0) {\n\t\tif (!*loopro && errno == EROFS)\n\t\t\tffd = open(file, mode = O_RDONLY);\n\t\tif (ffd < 0) {\n\t\t\tperror(file);"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_DEAD_STORE","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Dead store","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/errorcodes.c","index":-1},"region":{"startLine":23,"endLine":23,"charOffset":-1,"byteOffset":-1,"snippet":{"text":" * include errors that are specific to the watchdog code.\n */\n\nconst char *wd_strerror(int err)\n{\n\tchar *str = \"\";\n\n\tswitch (err) {\n\t\tcase ENOERR:\t\tstr = \"no error\"; break;\n\t\tcase EREBOOT:\t\tstr = \"unconditional reboot requested\"; break;\n\t\tcase ERESET:\t\tstr = \"unconditional hard reset requested\"; break;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1,"x-trace":[{"position":0,"source":"src/errorcodes.c","lineStart":23,"lineEnd":23,"columnStart":8,"columnEnd":8,"description":"char *str = \"\"","snippet":" * include errors that are specific to the watchdog code.\n */\n\nconst char *wd_strerror(int err)\n{\n\tchar *str = \"\";\n\n\tswitch (err) {\n\t\tcase ENOERR:\t\tstr = \"no error\"; break;\n\t\tcase EREBOOT:\t\tstr = \"unconditional reboot requested\"; break;\n\t\tcase ERESET:\t\tstr = \"unconditional hard reset requested\"; break;"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_PRIVACY_VIOLATION_HEAP","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Privacy violation from a memory dump","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":906,"endLine":906,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (loop) {\n\t\t\t\t\topts = opts0;\n\t\t\t\t\ttype = type0;\n\t\t\t\t}\n\t\t\t\tif (opts) {\n\t\t\t\t\topts = realloc(xstrdup(opts), strlen(opts) + 4);\n\t\t\t\t\tstrcat(opts, \",ro\");\n\t\t\t\t} else\n\t\t\t\t\topts = \"ro\";\n\t\t\t\tif (type && !strcmp(type, \"guess\"))\n\t\t\t\t\ttype = 0;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_INSECURE_API_SETUID","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Unsafe function: setuid","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":706,"endLine":706,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (stat(mountprog, &statbuf) == 0) {\n\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n\n\t\t\t\t\tsetuid(getuid());\n\t\t\t\t\tsetgid(getgid());\n\t\t\t\t\too = fix_opts_string(flags, extra_opts);\n\t\t\t\t\tmountargs[i++] = mountprog;\n\t\t\t\t\tmountargs[i++] = spec;\n\t\t\t\t\tmountargs[i++] = node;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":706,"lineEnd":706,"columnStart":6,"columnEnd":6,"description":"setuid(getuid())","snippet":"\t\t\tif (stat(mountprog, &statbuf) == 0) {\n\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n\n\t\t\t\t\tsetuid(getuid());\n\t\t\t\t\tsetgid(getgid());\n\t\t\t\t\too = fix_opts_string(flags, extra_opts);\n\t\t\t\t\tmountargs[i++] = mountprog;\n\t\t\t\t\tmountargs[i++] = spec;\n\t\t\t\t\tmountargs[i++] = node;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":706,"endLine":706,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (stat(mountprog, &statbuf) == 0) {\n\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n\n\t\t\t\t\tsetuid(getuid());\n\t\t\t\t\tsetgid(getgid());\n\t\t\t\t\too = fix_opts_string(flags, extra_opts);\n\t\t\t\t\tmountargs[i++] = mountprog;\n\t\t\t\t\tmountargs[i++] = spec;\n\t\t\t\t\tmountargs[i++] = node;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":707,"endLine":707,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n\n\t\t\t\t\tsetuid(getuid());\n\t\t\t\t\tsetgid(getgid());\n\t\t\t\t\too = fix_opts_string(flags, extra_opts);\n\t\t\t\t\tmountargs[i++] = mountprog;\n\t\t\t\t\tmountargs[i++] = spec;\n\t\t\t\t\tmountargs[i++] = node;\n\t\t\t\t\tif (mount_nomtab)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":707,"lineEnd":707,"columnStart":6,"columnEnd":6,"description":"setgid(getgid())","snippet":"\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n\n\t\t\t\t\tsetuid(getuid());\n\t\t\t\t\tsetgid(getgid());\n\t\t\t\t\too = fix_opts_string(flags, extra_opts);\n\t\t\t\t\tmountargs[i++] = mountprog;\n\t\t\t\t\tmountargs[i++] = spec;\n\t\t\t\t\tmountargs[i++] = node;\n\t\t\t\t\tif (mount_nomtab)"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":707,"endLine":707,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (fork() == 0) {\n\t\t\t\t\tchar *oo, *mountargs[10];\n\t\t\t\t\tint i = 0;\n\n\t\t\t\t\tsetuid(getuid());\n\t\t\t\t\tsetgid(getgid());\n\t\t\t\t\too = fix_opts_string(flags, extra_opts);\n\t\t\t\t\tmountargs[i++] = mountprog;\n\t\t\t\t\tmountargs[i++] = spec;\n\t\t\t\t\tmountargs[i++] = node;\n\t\t\t\t\tif (mount_nomtab)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_SENSITIVE_DATA_HARDCODED","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Hardcoded sensitive data","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/configfile.c","index":-1},"region":{"startLine":80,"endLine":80,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"int maxload5 = 0;\nint maxload15 = 0;\nint minpages = 0;\nint minalloc = 0;\nint maxtemp = 90;\nint pingcount = 3;\nint temp_poweroff = TRUE;\nint sigterm_delay = 5;\t/* Seconds from first SIGTERM to sending SIGKILL during shutdown. */\nint repair_max = 1; /* Number of repair attempts without success. */\n\nchar *devname = NULL;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"include/extern.h","index":-1},"region":{"startLine":76,"endLine":76,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"extern int maxload5;\nextern int maxload15;\nextern int minpages;\nextern int minalloc;\nextern int maxtemp;\nextern int pingcount;\nextern int temp_poweroff;\nextern int sigterm_delay;\nextern int repair_max;\n\nextern char *devname;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_NULL_POINT_ARGUMENT","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Function calling with invalid null argument","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":523,"endLine":523,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tmnt.mnt_freq = mnt.mnt_passno = 0;\n\n\t\tif (my_addmntent(mfp, &mnt) == 1)\n\t\t\tdie(EX_FILEIO, \"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t}\n\tif (fchmod(fileno(mfp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)\n\t\tif (errno != EROFS)\n\t\t\tdie(EX_FILEIO, \"mount: error changing mode of %s: %s\", MOUNTED, strerror(errno));\n\tmy_endmntent(mfp);\n\n\tunlock_mtab();"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":523,"lineEnd":523,"columnStart":13,"columnEnd":34,"description":"fileno(mfp->mntent_fp)","snippet":"\t\tmnt.mnt_freq = mnt.mnt_passno = 0;\n\n\t\tif (my_addmntent(mfp, &mnt) == 1)\n\t\t\tdie(EX_FILEIO, \"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t}\n\tif (fchmod(fileno(mfp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)\n\t\tif (errno != EROFS)\n\t\t\tdie(EX_FILEIO, \"mount: error changing mode of %s: %s\", MOUNTED, strerror(errno));\n\tmy_endmntent(mfp);\n\n\tunlock_mtab();"},{"position":1,"source":"src/mount.c","lineStart":512,"lineEnd":512,"columnStart":7,"columnEnd":7,"description":"if ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\")))","snippet":"\tmfp = my_setmntent(MOUNTED, \"a+\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL)\n\t\tdie(EX_FILEIO, \"mount: can't open %s for writing: %s\", MOUNTED, strerror(errno));\n\n\t/* Find the root entry by looking it up in fstab */\n\tif ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\"))) {\n\t\tparse_opts(xstrdup(fstab->mnt_opts), &flags, &extra_opts);\n\t\tmnt.mnt_dir = \"/\";\n\t\tmnt.mnt_fsname = canonicalize(fstab->mnt_fsname);\n\t\tmnt.mnt_type = fstab->mnt_type;\n\t\tmnt.mnt_opts = fix_opts_string(flags, extra_opts);"},{"position":2,"source":"src/mount.c","lineStart":508,"lineEnd":508,"columnStart":21,"columnEnd":39,"description":"mfp->mntent_fp == NULL","snippet":"\tmntFILE *mfp;\n\n\tlock_mtab();\n\n\tmfp = my_setmntent(MOUNTED, \"a+\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL)\n\t\tdie(EX_FILEIO, \"mount: can't open %s for writing: %s\", MOUNTED, strerror(errno));\n\n\t/* Find the root entry by looking it up in fstab */\n\tif ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\"))) {\n\t\tparse_opts(xstrdup(fstab->mnt_opts), &flags, &extra_opts);"},{"position":3,"source":"src/mount.c","lineStart":508,"lineEnd":508,"columnStart":6,"columnEnd":13,"description":"mfp == NULL","snippet":"\tmntFILE *mfp;\n\n\tlock_mtab();\n\n\tmfp = my_setmntent(MOUNTED, \"a+\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL)\n\t\tdie(EX_FILEIO, \"mount: can't open %s for writing: %s\", MOUNTED, strerror(errno));\n\n\t/* Find the root entry by looking it up in fstab */\n\tif ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\"))) {\n\t\tparse_opts(xstrdup(fstab->mnt_opts), &flags, &extra_opts);"},{"position":4,"source":"src/mount.c","lineStart":1255,"lineEnd":1255,"columnStart":3,"columnEnd":15,"description":"create_mtab()","snippet":"\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n\n\tswitch (argc) {\n\tcase 0:\n\t\t/* mount -a */"},{"position":5,"source":"src/mount.c","lineStart":1253,"lineEnd":1253,"columnStart":7,"columnEnd":23,"description":"mount_verbose > 1","snippet":"\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n\n\tswitch (argc) {"},{"position":6,"source":"src/mount.c","lineStart":1252,"lineEnd":1252,"columnStart":23,"columnEnd":43,"description":"mtab_does_not_exist()","snippet":"\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n"},{"position":7,"source":"src/mount.c","lineStart":1252,"lineEnd":1252,"columnStart":6,"columnEnd":7,"description":"!mount_nomtab","snippet":"\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n"},{"position":8,"source":"src/mount.c","lineStart":1246,"lineEnd":1246,"columnStart":6,"columnEnd":26,"description":"getuid() != geteuid()","snippet":"\t\tif (options)\n\t\t\tusage(stderr, EX_USAGE);\n\t\treturn print_all(types);\n\t}\n\n\tif (getuid() != geteuid()) {\n\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n"},{"position":9,"source":"src/mount.c","lineStart":1240,"lineEnd":1240,"columnStart":6,"columnEnd":14,"description":"argc == 0","snippet":"\t\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc == 0 && !all) {\n\t\tif (options)\n\t\t\tusage(stderr, EX_USAGE);\n\t\treturn print_all(types);\n\t}\n"},{"position":10,"source":"src/mount.c","lineStart":1186,"lineEnd":1187,"columnStart":9,"columnEnd":12,"description":"(c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL)) != EOF","snippet":"\targc0 = argc;\n\targv0 = argv;\n\tenvp0 = environ;\n#endif\n\n\twhile ((c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL))\n\t       != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* mount everything in fstab */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* fake (don't actually do mount(2) call) */"},{"position":11,"source":"src/mount.c","lineStart":1177,"lineEnd":1177,"columnStart":6,"columnEnd":11,"description":"fd > 2","snippet":"\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;\n\targv0 = argv;"},{"position":12,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":61,"columnEnd":67,"description":"fd == 2","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"},{"position":13,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":50,"columnEnd":56,"description":"fd == 1","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"},{"position":14,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":9,"columnEnd":45,"description":"(fd = open(\"/dev/null\", O_RDWR)) == 0","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_INSECURE_API_GETHOST","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"DNS lookup usage for an authentication","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":290,"endLine":290,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tfprintf(ph, \"To: %s\\n\", admin);\n\t\t\t\tif (ferror(ph) != 0) {\n\t\t\t\t\tlog_message(LOG_ERR, \"cannot send mail (errno = %d)\", errno);\n\t\t\t\t} else {\n\t\t\t\t\t/* if possible use the full name including domain */\n\t\t\t\t\tif ((hp = gethostbyname(myname)) != NULL)\n\t\t\t\t\t\tfprintf(ph, \"Subject: %s is going down!\\n\\n\", hp->h_name);\n\t\t\t\t\telse\n\t\t\t\t\t\tfprintf(ph, \"Subject: %s is going down!\\n\\n\", myname);\n\t\t\t\t\tif (ferror(ph) != 0) {\n\t\t\t\t\t\tlog_message(LOG_ERR, \"cannot send mail (errno = %d)\", errno);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_FORMAT_STRING","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Unsafe format string","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":163,"endLine":163,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tmc->nxt = mc->prev = NULL;\n\n\tfnam = _PATH_FSTAB;\n\tmfp = my_setmntent(fnam, \"r\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\terror(\"warning: can't open %s: %s\", _PATH_FSTAB, strerror(errno));\n\t\treturn;\n\t}\n\tread_mntentchn(mfp, fnam, mc);\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":641,"endLine":641,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tloopdev = opt_loopdev;\n\n\tlooptype = (type && strncmp(\"lo@\", type, 3) == 0);\n\tif (looptype) {\n\t\tif (loopdev)\n\t\t\terror(\"mount: loop device specified twice\");\n\t\tloopdev = type + 3;\n\t\ttype = opt_vfstype;\n\t} else if (opt_vfstype) {\n\t\tif (type)\n\t\t\terror(\"mount: type specified twice\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":875,"endLine":875,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (u && is_in_proc(lowtype))\n\t\t\t\t\terror(\"mount: probably you meant %s\", lowtype);\n\t\t\t\telse if (!strncmp(lowtype, \"iso\", 3) && is_in_proc(\"iso9660\"))\n\t\t\t\t\terror(\"mount: maybe you meant iso9660 ?\");\n\t\t\t\tfree(lowtype);\n\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);\n\t\t\tbreak;\n\t\tcase ENOTBLK:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":148,"endLine":148,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\telse\n\t\t\terror(\"mount: Could not find any loop device. Maybe this kernel does not know\\n\"\n\t\t\t      \"       about the loop device (then recompile or `insmod loop.o'), or\\n\"\n\t\t\t      \"       maybe /dev/loop# has the wrong major number?\");\n\t} else\n\t\terror(\"mount: could not find any free loop device\");\n\treturn 0;\n}\n\nint set_loop(const char *device, const char *file, int offset, const char *encryption, int *loopro)\n{"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":814,"endLine":814,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\talready(spec, node);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tif (lstat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s does not exist\", node);\n\t\t\telse if (stat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s is a symbolic link to nowhere\", node);\n\t\t\telse if (stat(spec, &statbuf))\n\t\t\t\terror(\"mount: special device %s does not exist\", spec);\n\t\t\telse {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":341,"endLine":341,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tgoto leave;\n\t}\n\n\tmftmp = my_setmntent(MOUNTED_TEMP, \"w\");\n\tif (mftmp == NULL || mftmp->mntent_fp == NULL) {\n\t\terror(\"can't open %s (%s) - mtab not updated\", MOUNTED_TEMP, strerror(errno));\n\t\tgoto leave;\n\t}\n\n\twhile ((mnt = my_getmntent(mfp))) {\n\t\tif (streq(mnt->mnt_dir, dir)) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1263,"endLine":1263,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tswitch (argc) {\n\tcase 0:\n\t\t/* mount -a */\n\t\tresult = mount_all(types, options);\n\t\tif (result == 0 && mount_verbose)\n\t\t\terror(\"not mounted anything\");\n\t\tbreak;\n\n\tcase 1:\n\t\t/* mount [-nfrvw] [-o options] special | node */\n\t\tif (types != NULL)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":151,"endLine":151,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else\n\tvsprintf(buf, fmt, args);\n#endif\n\tva_end(args);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":112,"endLine":112,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tmc->mnt_opts = mnt->mnt_opts;\n\t\tmc->nxt = NULL;\n\t}\n\tmc0->prev = mc;\n\tif (ferror(mfp->mntent_fp)) {\n\t\terror(\"warning: error reading %s: %s\", fnam, strerror(errno));\n\t\tmc0->nxt = mc0->prev = NULL;\n\t}\n\tmy_endmntent(mfp);\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":646,"endLine":646,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\terror(\"mount: loop device specified twice\");\n\t\tloopdev = type + 3;\n\t\ttype = opt_vfstype;\n\t} else if (opt_vfstype) {\n\t\tif (type)\n\t\t\terror(\"mount: type specified twice\");\n\t\telse\n\t\t\ttype = opt_vfstype;\n\t}\n\n\tloop = ((flags & MS_LOOP) || loopdev || opt_offset || opt_encryption);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1095,"endLine":1095,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tfor (cp = childhead.nxt; cp; cp = cp->nxt) {\n\t\tpid_t p = -1;\n\t\tif (optfork) {\n\t\t\tp = fork();\n\t\t\tif (p == -1)\n\t\t\t\terror(\"mount: cannot fork: %s\", strerror(errno));\n\t\t\telse if (p != 0)\n\t\t\t\tcp->pid = p;\n\t\t}\n\n\t\t/* if child, or not forked, do the mounting */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":882,"endLine":882,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);\n\t\t\tbreak;\n\t\tcase ENOTBLK:\n\t\t\tif (stat(spec, &statbuf))\t/* strange ... */\n\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))\n\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":161,"endLine":161,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t/* Let us hope fstab has a line \"proc /proc ...\"\n\t\t   and not \"none /proc ...\" */\n\t\terror(\"umount: %s: device is busy\", dev);\n\t\tbreak;\n\tcase ENOENT:\n\t\terror(\"umount: %s: not found\", dev);\n\t\tbreak;\n\tcase EPERM:\n\t\terror(\"umount: %s: must be superuser to umount\", dev);\n\t\tbreak;\n\tcase EACCES:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":806,"endLine":806,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {\n\t\t\t\t/* heuristic: if /proc/version exists, then probably proc is mounted */\n\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */\n\t\t\t\t\terror(\"mount: proc already mounted\");\n\t\t\t} else {\n\t\t\t\terror(\"mount: %s already mounted or %s busy\", spec, node);\n\t\t\t\talready(spec, node);\n\t\t\t}\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":861,"endLine":861,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: %s has wrong major or minor number\", spec);\n\t\t\telse if (procfs) {\n\t\t\t\tchar *lowtype, *p;\n\t\t\t\tint u;\n\n\t\t\t\terror(\"mount: fs type %s not supported by kernel\", type);\n\n\t\t\t\t/* maybe this loser asked for FAT or ISO9660 or isofs */\n\t\t\t\tlowtype = xstrdup(type);\n\t\t\t\tu = 0;\n\t\t\t\tfor (p = lowtype; *p; p++) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":170,"endLine":170,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase EACCES:\n\t\terror(\"umount: %s: block devices not permitted on fs\", dev);\n\t\tbreak;\n\tdefault:\n\t\terror(\"umount: %s: %s\", dev, strerror(err));\n\t\tbreak;\n\t}\n}\n\n/* Umount a single device.  Return a status code, so don't exit"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":140,"endLine":142,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\telse if (!someloop) {\n\t\tif (loop_known == 1)\n\t\t\terror(\"mount: Could not find any loop device.\\n\"\n\t\t\t      \"       Maybe /dev/loop# has a wrong major number?\");\n\t\telse if (loop_known == -1)\n\t\t\terror(\"mount: Could not find any loop device, and, according to %s,\\n\"\n\t\t\t      \"       this kernel does not know about the loop device.\\n\"\n\t\t\t      \"       (If so, then recompile or `insmod loop.o'.)\", PROC_DEVICES);\n\t\telse\n\t\t\terror(\"mount: Could not find any loop device. Maybe this kernel does not know\\n\"\n\t\t\t      \"       about the loop device (then recompile or `insmod loop.o'), or\\n\"\n\t\t\t      \"       maybe /dev/loop# has the wrong major number?\");\n\t} else"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":112,"endLine":112,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"void die(int err, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt, args);\n\tfprintf(stderr, \"\\n\");\n\tva_end(args);\n\n\tunlock_mtab();\n\texit(err);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":765,"endLine":765,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tmfp = my_setmntent(MOUNTED, \"a+\");\n\t\t\t\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\t\t\t\terror(\"mount: can't open %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif ((my_addmntent(mfp, &mnt)) == 1)\n\t\t\t\t\t\terror(\"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t\tmy_endmntent(mfp);\n\t\t\t\t}\n\t\t\t\tunlock_mtab();\n\t\t\t}\n\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":167,"endLine":167,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase EPERM:\n\t\terror(\"umount: %s: must be superuser to umount\", dev);\n\t\tbreak;\n\tcase EACCES:\n\t\terror(\"umount: %s: block devices not permitted on fs\", dev);\n\t\tbreak;\n\tdefault:\n\t\terror(\"umount: %s: %s\", dev, strerror(err));\n\t\tbreak;\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":142,"endLine":142,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tfnam = PROC_MOUNTS;\n\t\tif (mfp != NULL)\n\t\t\tfree(mfp);\n\t\tmfp = my_setmntent(fnam, \"r\");\n\t\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\t\terror(\"warning: can't open %s: %s\", MOUNTED, strerror(errsv));\n\t\t\treturn;\n\t\t}\n\t\tif (mount_verbose)\n\t\t\tprintf(\"mount: could not open %s - using %s instead\\n\", MOUNTED, PROC_MOUNTS);\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":889,"endLine":889,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\terror(\"mount: %s is not a valid block device\", spec);\n\t\t\tbreak;\n\t\tcase EACCES:\t/* pre-linux 1.1.38, 1.1.41 and later */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":164,"endLine":164,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase ENOENT:\n\t\terror(\"umount: %s: not found\", dev);\n\t\tbreak;\n\tcase EPERM:\n\t\terror(\"umount: %s: must be superuser to umount\", dev);\n\t\tbreak;\n\tcase EACCES:\n\t\terror(\"umount: %s: block devices not permitted on fs\", dev);\n\t\tbreak;\n\tdefault:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":897,"endLine":897,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\terror(\"mount: %s is not a valid block device\", spec);\n\t\t\tbreak;\n\t\tcase EACCES:\t/* pre-linux 1.1.38, 1.1.41 and later */\n\t\tcase EROFS:\t/* linux 1.1.38 and later */\n\t\t\tif (added_ro) {\n\t\t\t\terror(\"mount: block device %s is not permitted on its filesystem\", spec);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tadded_ro = 1;\n\t\t\t\tif (loop) {\n\t\t\t\t\topts = opts0;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":825,"endLine":825,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terrno = mnt_err;\n\t\t\t\tperror(\"mount\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOTDIR:\n\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\t{\n\t\t\t\tint fd, size;\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":490,"endLine":490,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tint ret = 1;\n\n\tif ((mc = getmntfile(node)) != NULL)\n\t\terror(\"mount: according to mtab, %s is already mounted on %s\", mc->mnt_fsname, node);\n\telse if ((mc = getmntfile(spec)) != NULL)\n\t\terror(\"mount: according to mtab, %s is mounted on %s\", spec, mc->mnt_dir);\n\telse\n\t\tret = 0;\n\treturn ret;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":158,"endLine":158,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\terror(\"umount: %s: can't write superblock\", dev);\n\t\tbreak;\n\tcase EBUSY:\n\t\t/* Let us hope fstab has a line \"proc /proc ...\"\n\t\t   and not \"none /proc ...\" */\n\t\terror(\"umount: %s: device is busy\", dev);\n\t\tbreak;\n\tcase ENOENT:\n\t\terror(\"umount: %s: not found\", dev);\n\t\tbreak;\n\tcase EPERM:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":873,"endLine":873,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t\t*p = tolower(*p);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (u && is_in_proc(lowtype))\n\t\t\t\t\terror(\"mount: probably you meant %s\", lowtype);\n\t\t\t\telse if (!strncmp(lowtype, \"iso\", 3) && is_in_proc(\"iso9660\"))\n\t\t\t\t\terror(\"mount: maybe you meant iso9660 ?\");\n\t\t\t\tfree(lowtype);\n\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":887,"endLine":887,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))\n\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\terror(\"mount: %s is not a valid block device\", spec);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":808,"endLine":808,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */\n\t\t\t\t\terror(\"mount: proc already mounted\");\n\t\t\t} else {\n\t\t\t\terror(\"mount: %s already mounted or %s busy\", spec, node);\n\t\t\t\talready(spec, node);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tif (lstat(node, &statbuf))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":832,"endLine":832,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase EINVAL:\n\t\t\t{\n\t\t\t\tint fd, size;\n\n\t\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\t\terror(\"mount: %s not mounted already, or bad option\", node);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"mount: wrong fs type, bad option, bad superblock on %s,\\n\"\n\t\t\t\t\t      \"       or too many mounted file systems\", spec);\n\n\t\t\t\t\tif (stat(spec, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":816,"endLine":816,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tif (lstat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s does not exist\", node);\n\t\t\telse if (stat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s is a symbolic link to nowhere\", node);\n\t\t\telse if (stat(spec, &statbuf))\n\t\t\t\terror(\"mount: special device %s does not exist\", spec);\n\t\t\telse {\n\t\t\t\terrno = mnt_err;\n\t\t\t\tperror(\"mount\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":794,"endLine":794,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase EPERM:\n\t\t\tif (geteuid() == 0) {\n\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))\n\t\t\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\t\telse\n\t\t\t\t\terror(\"mount: permission denied\");\n\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (flags & MS_REMOUNT) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":840,"endLine":842,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t      \"       or too many mounted file systems\", spec);\n\n\t\t\t\t\tif (stat(spec, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)\n\t\t\t\t\t    && (fd = open(spec, O_RDONLY)) >= 0) {\n\t\t\t\t\t\tif (ioctl(fd, BLKGETSIZE, &size) == 0 && size <= 2)\n\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t    (\"       (aren't you trying to mount an extended partition,\\n\"\n\t\t\t\t\t\t\t     \"       instead of some logical partition inside?)\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":134,"endLine":134,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tif (!loop_known)\n\t\t\tloop_known = -1;\n\t}\n\n\tif (!somedev)\n\t\terror(\"mount: could not find any device /dev/loop#\");\n\telse if (!someloop) {\n\t\tif (loop_known == 1)\n\t\t\terror(\"mount: Could not find any loop device.\\n\"\n\t\t\t      \"       Maybe /dev/loop# has a wrong major number?\");\n\t\telse if (loop_known == -1)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/logmessage.c","index":-1},"region":{"startLine":127,"endLine":127,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tmemset(buf, 0, sizeof(buf));\n\n\tva_start(args, fmt);\n#if _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L\n\tvsnprintf(buf, sizeof(buf) - 1, fmt, args);\n#else\n\tvsprintf(buf, fmt, args);\n#endif\n\tva_end(args);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":878,"endLine":878,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\terror(\"mount: probably you meant %s\", lowtype);\n\t\t\t\telse if (!strncmp(lowtype, \"iso\", 3) && is_in_proc(\"iso9660\"))\n\t\t\t\t\terror(\"mount: maybe you meant iso9660 ?\");\n\t\t\t\tfree(lowtype);\n\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);\n\t\t\tbreak;\n\t\tcase ENOTBLK:\n\t\t\tif (stat(spec, &statbuf))\t/* strange ... */\n\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":101,"endLine":101,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (mount_mount_quiet)\n\t\treturn;\n\tfmt2 = xstrconcat2(fmt, \"\\n\");\n\tva_start(args, fmt);\n\tvfprintf(stderr, fmt2, args);\n\tva_end(args);\n\tfree(fmt2);\n}\n\n/* Fatal error.  Print message and exit.  */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":834,"endLine":835,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tint fd, size;\n\n\t\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\t\terror(\"mount: %s not mounted already, or bad option\", node);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"mount: wrong fs type, bad option, bad superblock on %s,\\n\"\n\t\t\t\t\t      \"       or too many mounted file systems\", spec);\n\n\t\t\t\t\tif (stat(spec, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)\n\t\t\t\t\t    && (fd = open(spec, O_RDONLY)) >= 0) {\n\t\t\t\t\t\tif (ioctl(fd, BLKGETSIZE, &size) == 0 && size <= 2)\n\t\t\t\t\t\t\terror"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":856,"endLine":856,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase EIO:\n\t\t\terror(\"mount: %s: can't read superblock\", spec);\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tif (is_in_proc(type) || !strcmp(type, \"guess\"))\n\t\t\t\terror(\"mount: %s has wrong major or minor number\", spec);\n\t\t\telse if (procfs) {\n\t\t\t\tchar *lowtype, *p;\n\t\t\t\tint u;\n\n\t\t\t\terror(\"mount: fs type %s not supported by kernel\", type);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":728,"endLine":728,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t} else if (fork() != -1) {\n\t\t\t\t\tint status;\n\t\t\t\t\twait(&status);\n\t\t\t\t\treturn status;\n\t\t\t\t} else\n\t\t\t\t\terror(\"cannot fork: %s\", strerror(errno));\n\t\t\t}\n\t\t}\n\n\tblock_signals(SIG_BLOCK);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":762,"endLine":762,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tmntFILE *mfp;\n\n\t\t\t\tlock_mtab();\n\t\t\t\tmfp = my_setmntent(MOUNTED, \"a+\");\n\t\t\t\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\t\t\t\terror(\"mount: can't open %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif ((my_addmntent(mfp, &mnt)) == 1)\n\t\t\t\t\t\terror(\"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t\tmy_endmntent(mfp);\n\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":792,"endLine":792,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\telse\n\t\tswitch (mnt_err) {\n\t\tcase EPERM:\n\t\t\tif (geteuid() == 0) {\n\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))\n\t\t\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\t\telse\n\t\t\t\t\terror(\"mount: permission denied\");\n\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":918,"endLine":918,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t      loop ? \"\" : \"block device \", spec0);\n\t\t\t\treturn try_mount_one(spec0, node0, type, opts, freq, pass, bg);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"mount: %s\", strerror(mnt_err));\n\t\t\tbreak;\n\t\t}\n\treturn EX_FAIL;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":818,"endLine":818,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (lstat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s does not exist\", node);\n\t\t\telse if (stat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s is a symbolic link to nowhere\", node);\n\t\t\telse if (stat(spec, &statbuf))\n\t\t\t\terror(\"mount: special device %s does not exist\", spec);\n\t\t\telse {\n\t\t\t\terrno = mnt_err;\n\t\t\t\tperror(\"mount\");\n\t\t\t}\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":892,"endLine":892,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\terror(\"mount: %s is not a valid block device\", spec);\n\t\t\tbreak;\n\t\tcase EACCES:\t/* pre-linux 1.1.38, 1.1.41 and later */\n\t\tcase EROFS:\t/* linux 1.1.38 and later */\n\t\t\tif (added_ro) {\n\t\t\t\terror(\"mount: block device %s is not permitted on its filesystem\", spec);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":137,"endLine":138,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (!somedev)\n\t\terror(\"mount: could not find any device /dev/loop#\");\n\telse if (!someloop) {\n\t\tif (loop_known == 1)\n\t\t\terror(\"mount: Could not find any loop device.\\n\"\n\t\t\t      \"       Maybe /dev/loop# has a wrong major number?\");\n\t\telse if (loop_known == -1)\n\t\t\terror(\"mount: Could not find any loop device, and, according to %s,\\n\"\n\t\t\t      \"       this kernel does not know about the loop device.\\n\"\n\t\t\t      \"       (If so, then recompile or `insmod loop.o'.)\", PROC_DEVICES);\n\t\telse"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":153,"endLine":153,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase EINVAL:\n\t\terror(\"umount: %s: not mounted\", dev);\n\t\tbreak;\n\tcase EIO:\n\t\terror(\"umount: %s: can't write superblock\", dev);\n\t\tbreak;\n\tcase EBUSY:\n\t\t/* Let us hope fstab has a line \"proc /proc ...\"\n\t\t   and not \"none /proc ...\" */\n\t\terror(\"umount: %s: device is busy\", dev);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":849,"endLine":849,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase EMFILE:\n\t\t\terror(\"mount table full\");\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\terror(\"mount: %s: can't read superblock\", spec);\n\t\t\tbreak;\n\t\tcase ENODEV:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":144,"endLine":146,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\telse if (loop_known == -1)\n\t\t\terror(\"mount: Could not find any loop device, and, according to %s,\\n\"\n\t\t\t      \"       this kernel does not know about the loop device.\\n\"\n\t\t\t      \"       (If so, then recompile or `insmod loop.o'.)\", PROC_DEVICES);\n\t\telse\n\t\t\terror(\"mount: Could not find any loop device. Maybe this kernel does not know\\n\"\n\t\t\t      \"       about the loop device (then recompile or `insmod loop.o'), or\\n\"\n\t\t\t      \"       maybe /dev/loop# has the wrong major number?\");\n\t} else\n\t\terror(\"mount: could not find any free loop device\");\n\treturn 0;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":147,"endLine":147,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"/* complain about a failed umount */\nstatic void complain(int err, const char *dev)\n{\n\tswitch (err) {\n\tcase ENXIO:\n\t\terror(\"umount: %s: invalid block device\", dev);\n\t\tbreak;\n\tcase EINVAL:\n\t\terror(\"umount: %s: not mounted\", dev);\n\t\tbreak;\n\tcase EIO:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":488,"endLine":488,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"{\n\tstruct mntentchn *mc;\n\tint ret = 1;\n\n\tif ((mc = getmntfile(node)) != NULL)\n\t\terror(\"mount: according to mtab, %s is already mounted on %s\", mc->mnt_fsname, node);\n\telse if ((mc = getmntfile(spec)) != NULL)\n\t\terror(\"mount: according to mtab, %s is mounted on %s\", spec, mc->mnt_dir);\n\telse\n\t\tret = 0;\n\treturn ret;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":150,"endLine":150,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tswitch (err) {\n\tcase ENXIO:\n\t\terror(\"umount: %s: invalid block device\", dev);\n\t\tbreak;\n\tcase EINVAL:\n\t\terror(\"umount: %s: not mounted\", dev);\n\t\tbreak;\n\tcase EIO:\n\t\terror(\"umount: %s: can't write superblock\", dev);\n\t\tbreak;\n\tcase EBUSY:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":335,"endLine":335,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tlock_mtab();\n\n\tmfp = my_setmntent(MOUNTED, \"r\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\terror(\"cannot open %s (%s) - mtab not updated\", MOUNTED, strerror(errno));\n\t\tgoto leave;\n\t}\n\n\tmftmp = my_setmntent(MOUNTED_TEMP, \"w\");\n\tif (mftmp == NULL || mftmp->mntent_fp == NULL) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":800,"endLine":800,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\terror(\"mount: %s is busy\", node);\n\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {\n\t\t\t\t/* heuristic: if /proc/version exists, then probably proc is mounted */\n\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":884,"endLine":885,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tbreak;\n\t\tcase ENOTBLK:\n\t\t\tif (stat(spec, &statbuf))\t/* strange ... */\n\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))\n\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":786,"endLine":786,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tblock_signals(SIG_UNBLOCK);\n\n\t/* Mount failed, complain, but don't die.  */\n\n\tif (type == 0)\n\t\terror(\"mount: you must specify the filesystem type\");\n\telse\n\t\tswitch (mnt_err) {\n\t\tcase EPERM:\n\t\t\tif (geteuid() == 0) {\n\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":804,"endLine":804,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\terror(\"mount: %s is busy\", node);\n\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {\n\t\t\t\t/* heuristic: if /proc/version exists, then probably proc is mounted */\n\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */\n\t\t\t\t\terror(\"mount: proc already mounted\");\n\t\t\t} else {\n\t\t\t\terror(\"mount: %s already mounted or %s busy\", spec, node);\n\t\t\t\talready(spec, node);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":912,"endLine":913,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tstrcat(opts, \",ro\");\n\t\t\t\t} else\n\t\t\t\t\topts = \"ro\";\n\t\t\t\tif (type && !strcmp(type, \"guess\"))\n\t\t\t\t\ttype = 0;\n\t\t\t\terror(\"mount: %s%s is write-protected, mounting read-only\",\n\t\t\t\t      loop ? \"\" : \"block device \", spec0);\n\t\t\t\treturn try_mount_one(spec0, node0, type, opts, freq, pass, bg);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"mount: %s\", strerror(mnt_err));"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":796,"endLine":796,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))\n\t\t\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\t\telse\n\t\t\t\t\terror(\"mount: permission denied\");\n\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\terror(\"mount: %s is busy\", node);\n\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":852,"endLine":852,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t}\n\t\tcase EMFILE:\n\t\t\terror(\"mount table full\");\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\terror(\"mount: %s: can't read superblock\", spec);\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tif (is_in_proc(type) || !strcmp(type, \"guess\"))\n\t\t\t\terror(\"mount: %s has wrong major or minor number\", spec);\n\t\t\telse if (procfs) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_SWITCH_MISSING_DEFAULT","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Switch missing default","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1188,"endLine":1235,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tenvp0 = environ;\n#endif\n\n\twhile ((c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL))\n\t       != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* mount everything in fstab */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* fake (don't actually do mount(2) call) */\n\t\t\t++fake;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\t++optfork;\n\t\t\tbreak;\n\t\tcase 'h':\t/* help */\n\t\t\tusage(stdout, 0);\n\t\t\tbreak;\n\t\tcase 'n':\t/* mount without writing in /etc/mtab */\n\t\t\t++mount_nomtab;\n\t\t\tbreak;\n\t\tcase 'o':\t/* specify mount options */\n\t\t\tif (options)\n\t\t\t\toptions = xstrconcat3(options, \",\", optarg);\n\t\t\telse\n\t\t\t\toptions = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'r':\t/* mount readonly */\n\t\t\treadonly = 1;\n\t\t\treadwrite = 0;\n\t\t\tbreak;\n\t\tcase 's':\t/* allow sloppy mount options */\n\t\t\tsloppy = 1;\n\t\t\tbreak;\n\t\tcase 't':\t/* specify file system types */\n\t\t\ttypes = parse_list(optarg);\n\t\t\tbreak;\n\t\tcase 'v':\t/* be chatty - very chatty if repeated */\n\t\t\t++mount_verbose;\n\t\t\tbreak;\n\t\tcase 'V':\t/* version */\n\t\t\tprintf(\"mount: %s\\n\", version);\n\t\t\texit(0);\n\t\tcase 'w':\t/* mount read/write */\n\t\t\treadwrite = 1;\n\t\t\treadonly = 0;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(stderr, EX_USAGE);\n\t\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc == 0 && !all) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":352,"endLine":386,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tstruct mntentchn *mc, *fs;\n\tchar *file;\n\tint result = 0;\n\n\twhile ((c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* umount everything */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* force umount (needs kernel support) */\n#if 0\n\t\t\t++force;\n#else\n\t\t\tdie(2, \"umount: forced umount not supported yet\");\n#endif\n\t\t\tbreak;\n\t\tcase 'h':\t/* help */\n\t\t\tusage(stdout, 0);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t++umount_nomtab;\n\t\t\tbreak;\n\t\tcase 'r':\t/* remount read-only if umount fails */\n\t\t\t++remount;\n\t\t\tbreak;\n\t\tcase 'v':\t/* make noise */\n\t\t\t++umount_verbose;\n\t\t\tbreak;\n\t\tcase 'V':\t/* version */\n\t\t\tprintf(\"umount: %s\\n\", version);\n\t\t\texit(0);\n\t\tcase 't':\t/* specify file system type */\n\t\t\ttypes = parse_list(optarg);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(stderr, 1);\n\t\t}\n\n\tif (getuid() != geteuid()) {\n\t\tumount_suid = 1;\n\t\tif (all || types || umount_nomtab)\n\t\t\tdie(2, \"umount: only root can do that\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/read-conf.c","index":-1},"region":{"startLine":34,"endLine":41,"charOffset":-1,"byteOffset":-1,"snippet":{"text":" */\n\nstatic int is_white(char c)\n{\n\n\tswitch (c) {\n\t\tcase  ' ':\n\t\tcase '\\t':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\tcase '\\b':\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_DEPRECATED","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Deprecated construct","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":186,"endLine":186,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tswitch (loopinfo.lo_encrypt_type) {\n\tcase LO_CRYPT_NONE:\n\t\tloopinfo.lo_encrypt_key_size = 0;\n\t\tbreak;\n\tcase LO_CRYPT_XOR:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":281,"endLine":281,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (opts != NULL) {\n\t\t*extra_opts = xmalloc(strlen(opts) + 1);\n\t\t**extra_opts = '\\0';\n\n\t\tfor (opt = strtok(opts, \",\"); opt; opt = strtok(NULL, \",\"))\n\t\t\tif (!parse_string_opt(opt))\n\t\t\t\tparse_opt(opt, flags, *extra_opts);\n\t}\n\n\tif (readonly)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":131,"endLine":131,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (strings == NULL)\n\t\treturn NULL;\n\n\tlist = cons(strtok(strings, \",\"), NULL);\n\n\twhile ((t = strtok(NULL, \",\")) != NULL)\n\t\tlist = cons(t, list);\n\n\treturn list;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":256,"endLine":256,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tif (del_loop(spec))\n\t\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* new style mtab line? */\n\t\t\t\topts = mc->mnt_opts ? xstrdup(mc->mnt_opts) : \"\";\n\t\t\t\tfor (opts = strtok(opts, \",\"); opts; opts = strtok(NULL, \",\")) {\n\t\t\t\t\tif (!strncmp(opts, \"loop=\", 5)) {\n\t\t\t\t\t\tif (del_loop(opts + 5))\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":192,"endLine":192,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":196,"endLine":196,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":129,"endLine":129,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tchar *t;\n\n\tif (strings == NULL)\n\t\treturn NULL;\n\n\tlist = cons(strtok(strings, \",\"), NULL);\n\n\twhile ((t = strtok(NULL, \",\")) != NULL)\n\t\tlist = cons(t, list);\n\n\treturn list;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":226,"endLine":226,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t * changes around here.\n\t\t\t */\n\t\t\tto_in = (struct sockaddr_in *)&(net->to);\n\n\t\t\tto_in->sin_family = AF_INET;\n\t\t\tto_in->sin_addr.s_addr = inet_addr(act->name);\n\n\t\t\tif (to_in->sin_addr.s_addr == INADDR_NONE) {\n\t\t\t\tfatal_error(EX_USAGE, \"unknown host %s\", act->name);\n\t\t\t}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":256,"endLine":256,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tif (del_loop(spec))\n\t\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* new style mtab line? */\n\t\t\t\topts = mc->mnt_opts ? xstrdup(mc->mnt_opts) : \"\";\n\t\t\t\tfor (opts = strtok(opts, \",\"); opts; opts = strtok(NULL, \",\")) {\n\t\t\t\t\tif (!strncmp(opts, \"loop=\", 5)) {\n\t\t\t\t\t\tif (del_loop(opts + 5))\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":281,"endLine":281,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (opts != NULL) {\n\t\t*extra_opts = xmalloc(strlen(opts) + 1);\n\t\t**extra_opts = '\\0';\n\n\t\tfor (opt = strtok(opts, \",\"); opt; opt = strtok(NULL, \",\"))\n\t\t\tif (!parse_string_opt(opt))\n\t\t\t\tparse_opt(opt, flags, *extra_opts);\n\t}\n\n\tif (readonly)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_TYPE_CAST_ERROR","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Type cast error","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":97,"endLine":97,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\t\tstruct sockaddr_in from;\n\t\tfd_set fdmask;\n\t\tsocklen_t fromlen;\n\t\tstruct timeval tstart, timeout, dtimeout;\n\t\tstruct icmphdr *icp = (struct icmphdr *)outpack;\n\t\tstruct sockaddr_in *to_in = (struct sockaddr_in *)&to;\n\n\t\t/* setup a ping message */\n\t\ticp->type = ICMP_ECHO;\n\t\ticp->code = icp->checksum = 0;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/net.c","lineStart":97,"lineEnd":97,"columnStart":25,"columnEnd":43,"description":"(struct icmphdr *)outpack (struct icmphdr *)outpack","snippet":"\n\t\tstruct sockaddr_in from;\n\t\tfd_set fdmask;\n\t\tsocklen_t fromlen;\n\t\tstruct timeval tstart, timeout, dtimeout;\n\t\tstruct icmphdr *icp = (struct icmphdr *)outpack;\n\t\tstruct sockaddr_in *to_in = (struct sockaddr_in *)&to;\n\n\t\t/* setup a ping message */\n\t\ticp->type = ICMP_ECHO;\n\t\ticp->code = icp->checksum = 0;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":155,"endLine":155,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t\tlog_message(LOG_ERR, \"recvfrom gave errno = %d = '%s'\", err, strerror(err));\n\t\t\t\t\t\treturn (err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* check if packet is our ECHO */\n\t\t\t\t\ticp = (struct icmphdr *)(packet + (((struct ip *)packet)->ip_hl << 2));\n\n\t\t\t\t\tif (icp->type == ICMP_ECHOREPLY) {\n\t\t\t\t\t\tint rcv_id  = ntohs(icp->un.echo.id);\n\t\t\t\t\t\tint rcv_seq = ntohs(icp->un.echo.sequence);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/net.c","lineStart":155,"lineEnd":155,"columnStart":42,"columnEnd":55,"description":"(struct ip *)packet (struct ip *)packet","snippet":"\t\t\t\t\t\tlog_message(LOG_ERR, \"recvfrom gave errno = %d = '%s'\", err, strerror(err));\n\t\t\t\t\t\treturn (err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* check if packet is our ECHO */\n\t\t\t\t\ticp = (struct icmphdr *)(packet + (((struct ip *)packet)->ip_hl << 2));\n\n\t\t\t\t\tif (icp->type == ICMP_ECHOREPLY) {\n\t\t\t\t\t\tint rcv_id  = ntohs(icp->un.echo.id);\n\t\t\t\t\t\tint rcv_seq = ntohs(icp->un.echo.sequence);\n"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":155,"endLine":155,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t\tlog_message(LOG_ERR, \"recvfrom gave errno = %d = '%s'\", err, strerror(err));\n\t\t\t\t\t\treturn (err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* check if packet is our ECHO */\n\t\t\t\t\ticp = (struct icmphdr *)(packet + (((struct ip *)packet)->ip_hl << 2));\n\n\t\t\t\t\tif (icp->type == ICMP_ECHOREPLY) {\n\t\t\t\t\t\tint rcv_id  = ntohs(icp->un.echo.id);\n\t\t\t\t\t\tint rcv_seq = ntohs(icp->un.echo.sequence);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/net.c","lineStart":155,"lineEnd":155,"columnStart":12,"columnEnd":75,"description":"(struct icmphdr *)(packet + (((struct ip *)packet)->ip_hl << 2)) (struct icmphdr *)(packet + (((struct ip *)packet)->ip_hl << 2))","snippet":"\t\t\t\t\t\tlog_message(LOG_ERR, \"recvfrom gave errno = %d = '%s'\", err, strerror(err));\n\t\t\t\t\t\treturn (err);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t/* check if packet is our ECHO */\n\t\t\t\t\ticp = (struct icmphdr *)(packet + (((struct ip *)packet)->ip_hl << 2));\n\n\t\t\t\t\tif (icp->type == ICMP_ECHOREPLY) {\n\t\t\t\t\t\tint rcv_id  = ntohs(icp->un.echo.id);\n\t\t\t\t\t\tint rcv_seq = ntohs(icp->un.echo.sequence);\n"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_ARRAY_OUT_OF_BOUNDS","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Reference to array element out of bounds","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/xmalloc.c","index":-1},"region":{"startLine":72,"endLine":72,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/xmalloc.c","lineStart":72,"lineEnd":72,"columnStart":7,"columnEnd":7,"description":"t[n]","snippet":"\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"},{"position":1,"source":"src/xmalloc.c","lineStart":67,"lineEnd":67,"columnStart":19,"columnEnd":23,"description":"n < 0","snippet":"\nchar *xstrndup(const char *s, int n)\n{\n\tchar *t;\n\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;"},{"position":2,"source":"src/xmalloc.c","lineStart":67,"lineEnd":67,"columnStart":6,"columnEnd":11,"description":"s == NULL","snippet":"\nchar *xstrndup(const char *s, int n)\n{\n\tchar *t;\n\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":196,"endLine":196,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)\n\t\tif ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))\n\t\t    && !strncmp(s + 5, file, l)\n\t\t    && (s == opts || s[-1] == ',')\n\t\t    && (s[l + 5] == 0 || s[l + 5] == ','))\n\t\t\treturn mc;\n\n\treturn NULL;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/fstab.c","lineStart":196,"lineEnd":196,"columnStart":24,"columnEnd":28,"description":"s[-1]","snippet":"\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)\n\t\tif ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))\n\t\t    && !strncmp(s + 5, file, l)\n\t\t    && (s == opts || s[-1] == ',')\n\t\t    && (s[l + 5] == 0 || s[l + 5] == ','))\n\t\t\treturn mc;\n\n\treturn NULL;\n}"},{"position":1,"source":"src/fstab.c","lineStart":196,"lineEnd":196,"columnStart":11,"columnEnd":16,"description":"s == opts","snippet":"\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)\n\t\tif ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))\n\t\t    && !strncmp(s + 5, file, l)\n\t\t    && (s == opts || s[-1] == ',')\n\t\t    && (s[l + 5] == 0 || s[l + 5] == ','))\n\t\t\treturn mc;\n\n\treturn NULL;\n}"},{"position":2,"source":"src/fstab.c","lineStart":194,"lineEnd":194,"columnStart":41,"columnEnd":41,"description":"if ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))","snippet":"\t\treturn NULL;\n\n\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)\n\t\tif ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))\n\t\t    && !strncmp(s + 5, file, l)\n\t\t    && (s == opts || s[-1] == ',')\n\t\t    && (s[l + 5] == 0 || s[l + 5] == ','))\n\t\t\treturn mc;\n"},{"position":3,"source":"src/fstab.c","lineStart":194,"lineEnd":194,"columnStart":7,"columnEnd":32,"description":"(opts = mc->mnt_opts) != NULL","snippet":"\t\treturn NULL;\n\n\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)\n\t\tif ((opts = mc->mnt_opts) != NULL && (s = strstr(opts, \"loop=\"))\n\t\t    && !strncmp(s + 5, file, l)\n\t\t    && (s == opts || s[-1] == ',')\n\t\t    && (s[l + 5] == 0 || s[l + 5] == ','))\n\t\t\treturn mc;\n"},{"position":4,"source":"src/fstab.c","lineStart":188,"lineEnd":188,"columnStart":6,"columnEnd":7,"description":"!file","snippet":"{\n\tstruct mntentchn *mc;\n\tchar *opts, *s;\n\tint l;\n\n\tif (!file)\n\t\treturn NULL;\n\n\tl = strlen(file);\n\n\tfor (mc = mtab_head()->nxt; mc; mc = mc->nxt)"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_NULL_DEREFERENCE","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Null dereference","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":305,"endLine":305,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\thd = mtab_head();\n\tif (!hd->prev)\n\t\tdie(2, \"umount: cannot find list of filesystems to unmount\");\n\tfor (mc = hd->prev; mc != hd; mc = mc->prev) {\n\t\tif (matching_type(mc->mnt_type, types)) {\n\t\t\terrors |= umount_one(mc->mnt_fsname, mc->mnt_dir, mc->mnt_type, mc->mnt_opts);\n\t\t}\n\t}\n\n\tsync();"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/umount.c","lineStart":305,"lineEnd":305,"columnStart":21,"columnEnd":25,"description":"if (matching_type(mc->mnt_type, types))","snippet":"\n\thd = mtab_head();\n\tif (!hd->prev)\n\t\tdie(2, \"umount: cannot find list of filesystems to unmount\");\n\tfor (mc = hd->prev; mc != hd; mc = mc->prev) {\n\t\tif (matching_type(mc->mnt_type, types)) {\n\t\t\terrors |= umount_one(mc->mnt_fsname, mc->mnt_dir, mc->mnt_type, mc->mnt_opts);\n\t\t}\n\t}\n\n\tsync();"},{"position":1,"source":"src/umount.c","lineStart":304,"lineEnd":304,"columnStart":7,"columnEnd":16,"description":"mc = hd->prev","snippet":"\tint errors = 0;\n\n\thd = mtab_head();\n\tif (!hd->prev)\n\t\tdie(2, \"umount: cannot find list of filesystems to unmount\");\n\tfor (mc = hd->prev; mc != hd; mc = mc->prev) {\n\t\tif (matching_type(mc->mnt_type, types)) {\n\t\t\terrors |= umount_one(mc->mnt_fsname, mc->mnt_dir, mc->mnt_type, mc->mnt_opts);\n\t\t}\n\t}\n"},{"position":2,"source":"src/umount.c","lineStart":302,"lineEnd":302,"columnStart":6,"columnEnd":11,"description":"!hd->prev","snippet":"{\n\tstruct mntentchn *mc, *hd;\n\tint errors = 0;\n\n\thd = mtab_head();\n\tif (!hd->prev)\n\t\tdie(2, \"umount: cannot find list of filesystems to unmount\");\n\tfor (mc = hd->prev; mc != hd; mc = mc->prev) {\n\t\tif (matching_type(mc->mnt_type, types)) {\n\t\t\terrors |= umount_one(mc->mnt_fsname, mc->mnt_dir, mc->mnt_type, mc->mnt_opts);\n\t\t}"},{"position":3,"source":"src/umount.c","lineStart":400,"lineEnd":400,"columnStart":12,"columnEnd":28,"description":"umount_all(types)","snippet":"\targv += optind;\n\n\tif (all) {\n\t\tif (types == NULL)\n\t\t\ttypes = parse_list(xstrdup(\"noproc\"));\n\t\tresult = umount_all(types);\n\t} else if (argc < 1) {\n\t\tusage(stderr, 2);\n\t} else\n\t\twhile (argc--) {\n\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */"},{"position":4,"source":"src/umount.c","lineStart":388,"lineEnd":388,"columnStart":6,"columnEnd":26,"description":"getuid() != geteuid()","snippet":"\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(stderr, 1);\n\t\t}\n\n\tif (getuid() != geteuid()) {\n\t\tumount_suid = 1;\n\t\tif (all || types || umount_nomtab)\n\t\t\tdie(2, \"umount: only root can do that\");\n\t}\n"},{"position":5,"source":"src/umount.c","lineStart":351,"lineEnd":351,"columnStart":9,"columnEnd":71,"description":"(c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF","snippet":"\tstring_list options;\n\tstruct mntentchn *mc, *fs;\n\tchar *file;\n\tint result = 0;\n\n\twhile ((c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* umount everything */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* force umount (needs kernel support) */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1280,"endLine":1280,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n\n\t\tresult = mount_one(xstrdup(mc->mnt_fsname), xstrdup(mc->mnt_dir),\n\t\t\t\t   xstrdup(mc->mnt_type), mc->mnt_opts, options, 0, 0);\n\t\tbreak;\n\n\tcase 2:\n\t\t/* mount [-nfrvw] [-t vfstype] [-o options] special node */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":1280,"lineEnd":1280,"columnStart":30,"columnEnd":34,"description":"result = mount_one(xstrdup(mc->mnt_fsname), xstrdup(mc->mnt_dir),","snippet":"\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n\n\t\tresult = mount_one(xstrdup(mc->mnt_fsname), xstrdup(mc->mnt_dir),\n\t\t\t\t   xstrdup(mc->mnt_type), mc->mnt_opts, options, 0, 0);\n\t\tbreak;\n\n\tcase 2:\n\t\t/* mount [-nfrvw] [-t vfstype] [-o options] special node */"},{"position":1,"source":"src/mount.c","lineStart":1277,"lineEnd":1277,"columnStart":42,"columnEnd":69,"description":"(mc = getfsfile(*argv)) == NULL","snippet":"\t\tspec = canonicalize(*argv);\n\t\tif ((mc = getmntfile(spec)) == NULL &&\n\t\t    (mc = getfsspec(spec)) == NULL && (mc = getfsfile(spec)) == NULL &&\n\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n\n\t\tresult = mount_one(xstrdup(mc->mnt_fsname), xstrdup(mc->mnt_dir),\n\t\t\t\t   xstrdup(mc->mnt_type), mc->mnt_opts, options, 0, 0);\n\t\tbreak;"},{"position":2,"source":"src/mount.c","lineStart":1277,"lineEnd":1277,"columnStart":43,"columnEnd":63,"description":"mc = getfsfile(*argv)","snippet":"\t\tspec = canonicalize(*argv);\n\t\tif ((mc = getmntfile(spec)) == NULL &&\n\t\t    (mc = getfsspec(spec)) == NULL && (mc = getfsfile(spec)) == NULL &&\n\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n\n\t\tresult = mount_one(xstrdup(mc->mnt_fsname), xstrdup(mc->mnt_dir),\n\t\t\t\t   xstrdup(mc->mnt_type), mc->mnt_opts, options, 0, 0);\n\t\tbreak;"},{"position":3,"source":"src/mount.c","lineStart":1277,"lineEnd":1277,"columnStart":7,"columnEnd":34,"description":"(mc = getfsspec(*argv)) == NULL","snippet":"\t\tspec = canonicalize(*argv);\n\t\tif ((mc = getmntfile(spec)) == NULL &&\n\t\t    (mc = getfsspec(spec)) == NULL && (mc = getfsfile(spec)) == NULL &&\n\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n\n\t\tresult = mount_one(xstrdup(mc->mnt_fsname), xstrdup(mc->mnt_dir),\n\t\t\t\t   xstrdup(mc->mnt_type), mc->mnt_opts, options, 0, 0);\n\t\tbreak;"},{"position":4,"source":"src/mount.c","lineStart":1274,"lineEnd":1274,"columnStart":41,"columnEnd":67,"description":"(mc = getfsfile(spec)) == NULL","snippet":"\t\t\tusage(stderr, EX_USAGE);\n\n\t\t/* Try to find the other pathname in fstab.  */\n\t\tspec = canonicalize(*argv);\n\t\tif ((mc = getmntfile(spec)) == NULL &&\n\t\t    (mc = getfsspec(spec)) == NULL && (mc = getfsfile(spec)) == NULL &&\n\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n"},{"position":5,"source":"src/mount.c","lineStart":1274,"lineEnd":1274,"columnStart":7,"columnEnd":33,"description":"(mc = getfsspec(spec)) == NULL","snippet":"\t\t\tusage(stderr, EX_USAGE);\n\n\t\t/* Try to find the other pathname in fstab.  */\n\t\tspec = canonicalize(*argv);\n\t\tif ((mc = getmntfile(spec)) == NULL &&\n\t\t    (mc = getfsspec(spec)) == NULL && (mc = getfsfile(spec)) == NULL &&\n\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);\n"},{"position":6,"source":"src/mount.c","lineStart":1273,"lineEnd":1273,"columnStart":7,"columnEnd":34,"description":"(mc = getmntfile(spec)) == NULL","snippet":"\t\tif (types != NULL)\n\t\t\tusage(stderr, EX_USAGE);\n\n\t\t/* Try to find the other pathname in fstab.  */\n\t\tspec = canonicalize(*argv);\n\t\tif ((mc = getmntfile(spec)) == NULL &&\n\t\t    (mc = getfsspec(spec)) == NULL && (mc = getfsfile(spec)) == NULL &&\n\t\t    /* Try noncanonical name in fstab\n\t\t       perhaps /dev/cdrom or /dos is a symlink */\n\t\t    (mc = getfsspec(*argv)) == NULL && (mc = getfsfile(*argv)) == NULL)\n\t\t\tdie(EX_USAGE, \"mount: can't find %s in %s or %s\", spec, MOUNTED, _PATH_FSTAB);"},{"position":7,"source":"src/mount.c","lineStart":1252,"lineEnd":1252,"columnStart":6,"columnEnd":7,"description":"!mount_nomtab","snippet":"\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n"},{"position":8,"source":"src/mount.c","lineStart":1246,"lineEnd":1246,"columnStart":6,"columnEnd":26,"description":"getuid() != geteuid()","snippet":"\t\tif (options)\n\t\t\tusage(stderr, EX_USAGE);\n\t\treturn print_all(types);\n\t}\n\n\tif (getuid() != geteuid()) {\n\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n"},{"position":9,"source":"src/mount.c","lineStart":1240,"lineEnd":1240,"columnStart":6,"columnEnd":14,"description":"argc == 0","snippet":"\t\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc == 0 && !all) {\n\t\tif (options)\n\t\t\tusage(stderr, EX_USAGE);\n\t\treturn print_all(types);\n\t}\n"},{"position":10,"source":"src/mount.c","lineStart":1186,"lineEnd":1187,"columnStart":9,"columnEnd":12,"description":"(c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL)) != EOF","snippet":"\targc0 = argc;\n\targv0 = argv;\n\tenvp0 = environ;\n#endif\n\n\twhile ((c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL))\n\t       != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* mount everything in fstab */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* fake (don't actually do mount(2) call) */"},{"position":11,"source":"src/mount.c","lineStart":1177,"lineEnd":1177,"columnStart":6,"columnEnd":11,"description":"fd > 2","snippet":"\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;\n\targv0 = argv;"},{"position":12,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":61,"columnEnd":67,"description":"fd == 2","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"},{"position":13,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":50,"columnEnd":56,"description":"fd == 1","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"},{"position":14,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":9,"columnEnd":45,"description":"(fd = open(\"/dev/null\", O_RDWR)) == 0","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":418,"endLine":418,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {\n\t\t\t\t\tdie(2, \"umount: %s mount disagrees with the fstab\", file);\n\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/umount.c","lineStart":418,"lineEnd":418,"columnStart":11,"columnEnd":11,"description":"streq(mc->mnt_fsname, fs->mnt_fsname)","snippet":"\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {\n\t\t\t\t\tdie(2, \"umount: %s mount disagrees with the fstab\", file);\n\t\t\t\t}"},{"position":1,"source":"src/umount.c","lineStart":416,"lineEnd":416,"columnStart":36,"columnEnd":58,"description":"!(fs = getfsfile(file))","snippet":"\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {"},{"position":2,"source":"src/umount.c","lineStart":416,"lineEnd":416,"columnStart":38,"columnEnd":38,"description":"if (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))","snippet":"\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {"},{"position":3,"source":"src/umount.c","lineStart":416,"lineEnd":416,"columnStart":38,"columnEnd":57,"description":"fs = getfsfile(file)","snippet":"\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {"},{"position":4,"source":"src/umount.c","lineStart":416,"lineEnd":416,"columnStart":11,"columnEnd":11,"description":"if (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))","snippet":"\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {"},{"position":5,"source":"src/umount.c","lineStart":413,"lineEnd":413,"columnStart":8,"columnEnd":8,"description":"if (umount_suid)","snippet":"\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&"},{"position":6,"source":"src/umount.c","lineStart":410,"lineEnd":410,"columnStart":8,"columnEnd":9,"description":"!mc","snippet":"\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)\n\t\t\t\tprintf(\"Trying to umount %s\\n\", file);\n\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);"},{"position":7,"source":"src/umount.c","lineStart":406,"lineEnd":406,"columnStart":8,"columnEnd":25,"description":"umount_verbose > 1","snippet":"\t} else if (argc < 1) {\n\t\tusage(stderr, 2);\n\t} else\n\t\twhile (argc--) {\n\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)\n\t\t\t\tprintf(\"Trying to umount %s\\n\", file);\n\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);"},{"position":8,"source":"src/umount.c","lineStart":401,"lineEnd":401,"columnStart":13,"columnEnd":20,"description":"argc < 1","snippet":"\n\tif (all) {\n\t\tif (types == NULL)\n\t\t\ttypes = parse_list(xstrdup(\"noproc\"));\n\t\tresult = umount_all(types);\n\t} else if (argc < 1) {\n\t\tusage(stderr, 2);\n\t} else\n\t\twhile (argc--) {\n\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)"},{"position":9,"source":"src/umount.c","lineStart":388,"lineEnd":388,"columnStart":6,"columnEnd":26,"description":"getuid() != geteuid()","snippet":"\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(stderr, 1);\n\t\t}\n\n\tif (getuid() != geteuid()) {\n\t\tumount_suid = 1;\n\t\tif (all || types || umount_nomtab)\n\t\t\tdie(2, \"umount: only root can do that\");\n\t}\n"},{"position":10,"source":"src/umount.c","lineStart":351,"lineEnd":351,"columnStart":9,"columnEnd":71,"description":"(c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF","snippet":"\tstring_list options;\n\tstruct mntentchn *mc, *fs;\n\tchar *file;\n\tint result = 0;\n\n\twhile ((c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* umount everything */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* force umount (needs kernel support) */"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":523,"endLine":523,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tmnt.mnt_freq = mnt.mnt_passno = 0;\n\n\t\tif (my_addmntent(mfp, &mnt) == 1)\n\t\t\tdie(EX_FILEIO, \"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t}\n\tif (fchmod(fileno(mfp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)\n\t\tif (errno != EROFS)\n\t\t\tdie(EX_FILEIO, \"mount: error changing mode of %s: %s\", MOUNTED, strerror(errno));\n\tmy_endmntent(mfp);\n\n\tunlock_mtab();"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":523,"lineEnd":523,"columnStart":20,"columnEnd":25,"description":"if (fchmod(fileno(mfp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)","snippet":"\t\tmnt.mnt_freq = mnt.mnt_passno = 0;\n\n\t\tif (my_addmntent(mfp, &mnt) == 1)\n\t\t\tdie(EX_FILEIO, \"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t}\n\tif (fchmod(fileno(mfp->mntent_fp), S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)\n\t\tif (errno != EROFS)\n\t\t\tdie(EX_FILEIO, \"mount: error changing mode of %s: %s\", MOUNTED, strerror(errno));\n\tmy_endmntent(mfp);\n\n\tunlock_mtab();"},{"position":1,"source":"src/mount.c","lineStart":512,"lineEnd":512,"columnStart":7,"columnEnd":7,"description":"if ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\")))","snippet":"\tmfp = my_setmntent(MOUNTED, \"a+\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL)\n\t\tdie(EX_FILEIO, \"mount: can't open %s for writing: %s\", MOUNTED, strerror(errno));\n\n\t/* Find the root entry by looking it up in fstab */\n\tif ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\"))) {\n\t\tparse_opts(xstrdup(fstab->mnt_opts), &flags, &extra_opts);\n\t\tmnt.mnt_dir = \"/\";\n\t\tmnt.mnt_fsname = canonicalize(fstab->mnt_fsname);\n\t\tmnt.mnt_type = fstab->mnt_type;\n\t\tmnt.mnt_opts = fix_opts_string(flags, extra_opts);"},{"position":2,"source":"src/mount.c","lineStart":508,"lineEnd":508,"columnStart":6,"columnEnd":13,"description":"mfp == NULL","snippet":"\tmntFILE *mfp;\n\n\tlock_mtab();\n\n\tmfp = my_setmntent(MOUNTED, \"a+\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL)\n\t\tdie(EX_FILEIO, \"mount: can't open %s for writing: %s\", MOUNTED, strerror(errno));\n\n\t/* Find the root entry by looking it up in fstab */\n\tif ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\"))) {\n\t\tparse_opts(xstrdup(fstab->mnt_opts), &flags, &extra_opts);"},{"position":3,"source":"src/mount.c","lineStart":507,"lineEnd":507,"columnStart":2,"columnEnd":34,"description":"mfp = my_setmntent(MOUNTED, \"a+\")","snippet":"\tchar *extra_opts;\n\tmntFILE *mfp;\n\n\tlock_mtab();\n\n\tmfp = my_setmntent(MOUNTED, \"a+\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL)\n\t\tdie(EX_FILEIO, \"mount: can't open %s for writing: %s\", MOUNTED, strerror(errno));\n\n\t/* Find the root entry by looking it up in fstab */\n\tif ((fstab = getfsfile(\"/\")) || (fstab = getfsfile(\"root\"))) {"},{"position":4,"source":"src/mount.c","lineStart":1255,"lineEnd":1255,"columnStart":3,"columnEnd":15,"description":"create_mtab()","snippet":"\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n\n\tswitch (argc) {\n\tcase 0:\n\t\t/* mount -a */"},{"position":5,"source":"src/mount.c","lineStart":1253,"lineEnd":1253,"columnStart":7,"columnEnd":23,"description":"mount_verbose > 1","snippet":"\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n\n\tswitch (argc) {"},{"position":6,"source":"src/mount.c","lineStart":1252,"lineEnd":1252,"columnStart":23,"columnEnd":43,"description":"mtab_does_not_exist()","snippet":"\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n"},{"position":7,"source":"src/mount.c","lineStart":1252,"lineEnd":1252,"columnStart":6,"columnEnd":7,"description":"!mount_nomtab","snippet":"\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n\n\tif (!mount_nomtab && mtab_does_not_exist()) {\n\t\tif (mount_verbose > 1)\n\t\t\tprintf(\"mount: no %s found - creating it..\\n\", MOUNTED);\n\t\tcreate_mtab();\n\t}\n"},{"position":8,"source":"src/mount.c","lineStart":1246,"lineEnd":1246,"columnStart":6,"columnEnd":26,"description":"getuid() != geteuid()","snippet":"\t\tif (options)\n\t\t\tusage(stderr, EX_USAGE);\n\t\treturn print_all(types);\n\t}\n\n\tif (getuid() != geteuid()) {\n\t\tmount_suid = 1;\n\t\tif (types || options || readwrite || mount_nomtab || all || fake || argc != 1)\n\t\t\tdie(EX_USAGE, \"mount: only root can do that\");\n\t}\n"},{"position":9,"source":"src/mount.c","lineStart":1240,"lineEnd":1240,"columnStart":6,"columnEnd":14,"description":"argc == 0","snippet":"\t\t}\n\n\targc -= optind;\n\targv += optind;\n\n\tif (argc == 0 && !all) {\n\t\tif (options)\n\t\t\tusage(stderr, EX_USAGE);\n\t\treturn print_all(types);\n\t}\n"},{"position":10,"source":"src/mount.c","lineStart":1186,"lineEnd":1187,"columnStart":9,"columnEnd":12,"description":"(c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL)) != EOF","snippet":"\targc0 = argc;\n\targv0 = argv;\n\tenvp0 = environ;\n#endif\n\n\twhile ((c = getopt_long(argc, argv, \"afFhno:rsvVwt:\", longopts, NULL))\n\t       != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* mount everything in fstab */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* fake (don't actually do mount(2) call) */"},{"position":11,"source":"src/mount.c","lineStart":1177,"lineEnd":1177,"columnStart":6,"columnEnd":11,"description":"fd > 2","snippet":"\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;\n\targv0 = argv;"},{"position":12,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":61,"columnEnd":67,"description":"fd == 2","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"},{"position":13,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":50,"columnEnd":56,"description":"fd == 1","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"},{"position":14,"source":"src/mount.c","lineStart":1176,"lineEnd":1176,"columnStart":9,"columnEnd":45,"description":"(fd = open(\"/dev/null\", O_RDWR)) == 0","snippet":"\tint fd;\n\n\t/* People report that a mount called from init without console\n\t   writes error messages to /etc/mtab\n\t   Let us try to avoid getting fd's 0,1,2 */\n\twhile ((fd = open(\"/dev/null\", O_RDWR)) == 0 || fd == 1 || fd == 2) ;\n\tif (fd > 2)\n\t\tclose(fd);\n\n#ifdef DO_PS_FIDDLING\n\targc0 = argc;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":418,"endLine":418,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {\n\t\t\t\t\tdie(2, \"umount: %s mount disagrees with the fstab\", file);\n\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/umount.c","lineStart":418,"lineEnd":418,"columnStart":11,"columnEnd":11,"description":"streq(mc->mnt_fsname, fs->mnt_fsname)","snippet":"\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {\n\t\t\t\t\tdie(2, \"umount: %s mount disagrees with the fstab\", file);\n\t\t\t\t}"},{"position":1,"source":"src/umount.c","lineStart":416,"lineEnd":416,"columnStart":11,"columnEnd":11,"description":"if (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))","snippet":"\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&\n\t\t\t\t     !streq(mc->mnt_fsname, canonicalize(fs->mnt_fsname)))\n\t\t\t\t    || (!streq(mc->mnt_dir, fs->mnt_dir) &&\n\t\t\t\t\t!streq(mc->mnt_dir, canonicalize(fs->mnt_dir)))) {"},{"position":2,"source":"src/umount.c","lineStart":413,"lineEnd":413,"columnStart":8,"columnEnd":8,"description":"if (umount_suid)","snippet":"\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);\n\t\t\t\tif (!(fs = getfsspec(file)) && !(fs = getfsfile(file)))\n\t\t\t\t\tdie(2, \"umount: %s is not in the fstab (and you are not root)\", file);\n\t\t\t\tif ((!streq(mc->mnt_fsname, fs->mnt_fsname) &&"},{"position":3,"source":"src/umount.c","lineStart":410,"lineEnd":410,"columnStart":15,"columnEnd":15,"description":"if (!mc && umount_verbose)","snippet":"\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)\n\t\t\t\tprintf(\"Trying to umount %s\\n\", file);\n\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);"},{"position":4,"source":"src/umount.c","lineStart":410,"lineEnd":410,"columnStart":8,"columnEnd":9,"description":"!mc","snippet":"\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)\n\t\t\t\tprintf(\"Trying to umount %s\\n\", file);\n\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)\n\t\t\t\t\tdie(2, \"umount: %s is not mounted (according to mtab)\", file);"},{"position":5,"source":"src/umount.c","lineStart":409,"lineEnd":409,"columnStart":4,"columnEnd":24,"description":"mc = getmntfile(file)","snippet":"\t\twhile (argc--) {\n\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)\n\t\t\t\tprintf(\"Trying to umount %s\\n\", file);\n\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);\n\n\t\t\tif (umount_suid) {\n\t\t\t\tif (!mc)"},{"position":6,"source":"src/umount.c","lineStart":406,"lineEnd":406,"columnStart":8,"columnEnd":25,"description":"umount_verbose > 1","snippet":"\t} else if (argc < 1) {\n\t\tusage(stderr, 2);\n\t} else\n\t\twhile (argc--) {\n\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)\n\t\t\t\tprintf(\"Trying to umount %s\\n\", file);\n\n\t\t\tmc = getmntfile(file);\n\t\t\tif (!mc && umount_verbose)\n\t\t\t\tprintf(\"Could not find %s in mtab\\n\", file);"},{"position":7,"source":"src/umount.c","lineStart":401,"lineEnd":401,"columnStart":13,"columnEnd":20,"description":"argc < 1","snippet":"\n\tif (all) {\n\t\tif (types == NULL)\n\t\t\ttypes = parse_list(xstrdup(\"noproc\"));\n\t\tresult = umount_all(types);\n\t} else if (argc < 1) {\n\t\tusage(stderr, 2);\n\t} else\n\t\twhile (argc--) {\n\t\t\tfile = canonicalize(*argv);\t/* mtab paths are canonicalized */\n\t\t\tif (umount_verbose > 1)"},{"position":8,"source":"src/umount.c","lineStart":388,"lineEnd":388,"columnStart":6,"columnEnd":26,"description":"getuid() != geteuid()","snippet":"\t\tcase '?':\n\t\tdefault:\n\t\t\tusage(stderr, 1);\n\t\t}\n\n\tif (getuid() != geteuid()) {\n\t\tumount_suid = 1;\n\t\tif (all || types || umount_nomtab)\n\t\t\tdie(2, \"umount: only root can do that\");\n\t}\n"},{"position":9,"source":"src/umount.c","lineStart":351,"lineEnd":351,"columnStart":9,"columnEnd":71,"description":"(c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF","snippet":"\tstring_list options;\n\tstruct mntentchn *mc, *fs;\n\tchar *file;\n\tint result = 0;\n\n\twhile ((c = getopt_long(argc, argv, \"afhnrvVt:\", longopts, NULL)) != EOF)\n\t\tswitch (c) {\n\t\tcase 'a':\t/* umount everything */\n\t\t\t++all;\n\t\t\tbreak;\n\t\tcase 'f':\t/* force umount (needs kernel support) */"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_INJECTION_COMMAND","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Command injection","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":107,"endLine":107,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t} else {\t/* if (version == 1) */\n\n\t\t\tif (name == NULL)\n\t\t\t\texecl(rbinary, rbinary, \"repair\", parm, NULL);\n\t\t\telse\n\t\t\t\texecl(rbinary, rbinary, \"repair\", parm, name, NULL);\n\t\t}\n\n\t\t/* execl() should only return in case of an error */\n\t\t/* so we return the reboot code */\n\t\treturn (errno);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":275,"endLine":275,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tif (!freopen(filename_buf, \"a+\", stderr))\n\t\t\texit(errno);\n\n\t\t/* now start binary */\n\t\tif (version == 0) {\n\t\t\texecl(tbinary, tbinary, NULL);\n\t\t} else {\n\t\t\texecl(tbinary, tbinary, \"test\", NULL);\n\t\t}\n\n\t\t/* execl should only return in case of an error */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":721,"endLine":721,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tif (oo && *oo) {\n\t\t\t\t\t\tmountargs[i++] = \"-o\";\n\t\t\t\t\t\tmountargs[i++] = oo;\n\t\t\t\t\t}\n\t\t\t\t\tmountargs[i] = NULL;\n\t\t\t\t\texecv(mountprog, mountargs);\n\t\t\t\t\texit(1);\t/* exec failed */\n\t\t\t\t} else if (fork() != -1) {\n\t\t\t\t\tint status;\n\t\t\t\t\twait(&status);\n\t\t\t\t\treturn status;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":275,"endLine":275,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t * than we can write to it. */\n\t\tif ((stat(PATH_SENDMAIL, &buf) != 0) || ((buf.st_mode & S_IXUSR) == 0)) {\n\t\t\tlog_message(LOG_ERR, \"%s does not exist or is not executable (errno = %d)\", PATH_SENDMAIL, errno);\n\t\t} else {\n\t\t\tsprintf(exe, \"%s -i %s\", PATH_SENDMAIL, admin);\n\t\t\tph = popen(exe, \"w\");\n\t\t\tif (ph == NULL) {\n\t\t\t\tlog_message(LOG_ERR, \"cannot start %s (errno = %d)\", PATH_SENDMAIL, errno);\n\t\t\t} else {\n\t\t\t\tchar myname[MAXHOSTNAMELEN + 1];\n\t\t\t\tstruct hostent *hp;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":101,"endLine":101,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t/* now start binary */\n\t\tif (version == 0) {\n\t\t\tif (name == NULL)\n\t\t\t\texecl(rbinary, rbinary, parm, NULL);\n\t\t\telse\n\t\t\t\texecl(rbinary, rbinary, parm, name, NULL);\n\t\t} else {\t/* if (version == 1) */\n\n\t\t\tif (name == NULL)\n\t\t\t\texecl(rbinary, rbinary, \"repair\", parm, NULL);\n\t\t\telse"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":99,"endLine":99,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\texit(errno);\n\n\t\t/* now start binary */\n\t\tif (version == 0) {\n\t\t\tif (name == NULL)\n\t\t\t\texecl(rbinary, rbinary, parm, NULL);\n\t\t\telse\n\t\t\t\texecl(rbinary, rbinary, parm, name, NULL);\n\t\t} else {\t/* if (version == 1) */\n\n\t\t\tif (name == NULL)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":105,"endLine":105,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\telse\n\t\t\t\texecl(rbinary, rbinary, parm, name, NULL);\n\t\t} else {\t/* if (version == 1) */\n\n\t\t\tif (name == NULL)\n\t\t\t\texecl(rbinary, rbinary, \"repair\", parm, NULL);\n\t\t\telse\n\t\t\t\texecl(rbinary, rbinary, \"repair\", parm, name, NULL);\n\t\t}\n\n\t\t/* execl() should only return in case of an error */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/test_binary.c","index":-1},"region":{"startLine":277,"endLine":277,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\t\t/* now start binary */\n\t\tif (version == 0) {\n\t\t\texecl(tbinary, tbinary, NULL);\n\t\t} else {\n\t\t\texecl(tbinary, tbinary, \"test\", NULL);\n\t\t}\n\n\t\t/* execl should only return in case of an error */\n\t\t/* so we return that error */\n\t\texit(errno);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_OBSOLETE","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Obsolete construct","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":558,"endLine":558,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tusleep(swait);\n\t\tcheck_bin(NULL, test_timeout, 0);\n\n\t\t/* finally sleep for a full cycle */\n\t\t/* we have just triggered the device with the last check */\n\t\tusleep(twait);\n\n\t\tcount++;\n\n\t\t/* do verbose logging */\n\t\tif (verbose && logtick && (--ticker == 0)) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/shutdown.c","index":-1},"region":{"startLine":85,"endLine":85,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tlog_message(LOG_NOTICE, \"stopping daemon (%d.%d)\", MAJOR_VERSION, MINOR_VERSION);\n\tunlock_our_memory();\n\tclose_all();\n\tremove_pid_file();\n\tclose_logging();\n\tusleep(100000);\t\t/* 0.1s to make sure log is written */\n\texit(ecode);\n}\n\n/* panic: we're still alive but shouldn't */\nstatic void panic(void)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":186,"endLine":186,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tswitch (loopinfo.lo_encrypt_type) {\n\tcase LO_CRYPT_NONE:\n\t\tloopinfo.lo_encrypt_key_size = 0;\n\t\tbreak;\n\tcase LO_CRYPT_XOR:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":192,"endLine":192,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, LO_KEY_SIZE);\n\t\tloopinfo.lo_encrypt_key[LO_KEY_SIZE - 1] = 0;\n\t\tloopinfo.lo_encrypt_key_size = (int)strlen((char *)loopinfo.lo_encrypt_key);\n\t\tbreak;\n\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/watchdog.c","index":-1},"region":{"startLine":553,"endLine":553,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t/* test, or test/repair binaries in the watchdog.d directory */\n\t\tfor (act = tr_bin_list; act != NULL; act = act->next)\n\t\t\tdo_check(check_bin(act->name, test_timeout, act->version), repair_bin, act);\n\n\t\t/* in case test binaries return quickly */\n\t\tusleep(swait);\n\t\tcheck_bin(NULL, test_timeout, 0);\n\n\t\t/* finally sleep for a full cycle */\n\t\t/* we have just triggered the device with the last check */\n\t\tusleep(twait);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":129,"endLine":129,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tchar *t;\n\n\tif (strings == NULL)\n\t\treturn NULL;\n\n\tlist = cons(strtok(strings, \",\"), NULL);\n\n\twhile ((t = strtok(NULL, \",\")) != NULL)\n\t\tlist = cons(t, list);\n\n\treturn list;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":256,"endLine":256,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tif (del_loop(spec))\n\t\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* new style mtab line? */\n\t\t\t\topts = mc->mnt_opts ? xstrdup(mc->mnt_opts) : \"\";\n\t\t\t\tfor (opts = strtok(opts, \",\"); opts; opts = strtok(NULL, \",\")) {\n\t\t\t\t\tif (!strncmp(opts, \"loop=\", 5)) {\n\t\t\t\t\t\tif (del_loop(opts + 5))\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":281,"endLine":281,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (opts != NULL) {\n\t\t*extra_opts = xmalloc(strlen(opts) + 1);\n\t\t**extra_opts = '\\0';\n\n\t\tfor (opt = strtok(opts, \",\"); opt; opt = strtok(NULL, \",\"))\n\t\t\tif (!parse_string_opt(opt))\n\t\t\t\tparse_opt(opt, flags, *extra_opts);\n\t}\n\n\tif (readonly)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/wd_keepalive.c","index":-1},"region":{"startLine":72,"endLine":72,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tlog_message(LOG_NOTICE, \"stopping watchdog keepalive daemon (%d.%d)\", MAJOR_VERSION, MINOR_VERSION);\n\tunlock_our_memory();\n\tclose_all();\n\tremove_pid_file();\n\tclose_logging();\n\tusleep(100000);\t\t/* 0.1s to make sure log is written */\n\texit(ecode);\n}\n\nint main(int argc, char *const argv[])\n{"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":256,"endLine":256,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tif (del_loop(spec))\n\t\t\t\t\t\tgoto fail;\n\n\t\t\t\t/* new style mtab line? */\n\t\t\t\topts = mc->mnt_opts ? xstrdup(mc->mnt_opts) : \"\";\n\t\t\t\tfor (opts = strtok(opts, \",\"); opts; opts = strtok(NULL, \",\")) {\n\t\t\t\t\tif (!strncmp(opts, \"loop=\", 5)) {\n\t\t\t\t\t\tif (del_loop(opts + 5))\n\t\t\t\t\t\t\tgoto fail;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":281,"endLine":281,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (opts != NULL) {\n\t\t*extra_opts = xmalloc(strlen(opts) + 1);\n\t\t**extra_opts = '\\0';\n\n\t\tfor (opt = strtok(opts, \",\"); opt; opt = strtok(NULL, \",\"))\n\t\t\tif (!parse_string_opt(opt))\n\t\t\t\tparse_opt(opt, flags, *extra_opts);\n\t}\n\n\tif (readonly)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/daemon-pid.c","index":-1},"region":{"startLine":153,"endLine":153,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t/* and fork again to make sure we inherit all rights from init */\n\tif ((child_pid = fork()) < 0) {\n\t\t_exit(1);\n\t} else if (child_pid > 0) {\n\t\t/* fork was OK, give child time to write PID file. */\n\t\tusleep(10000);\n\t\t_exit(0);\n\t}\n\t/* now we're free */\n\n\t/* Okay, we're a daemon     */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":226,"endLine":226,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t * changes around here.\n\t\t\t */\n\t\t\tto_in = (struct sockaddr_in *)&(net->to);\n\n\t\t\tto_in->sin_family = AF_INET;\n\t\t\tto_in->sin_addr.s_addr = inet_addr(act->name);\n\n\t\t\tif (to_in->sin_addr.s_addr == INADDR_NONE) {\n\t\t\t\tfatal_error(EX_USAGE, \"unknown host %s\", act->name);\n\t\t\t}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":196,"endLine":196,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tcase LO_CRYPT_DES:\n\t\tpass = getpass(\"Password: \");\n\t\tstrncpy((char *)loopinfo.lo_encrypt_key, pass, 8);\n\t\tloopinfo.lo_encrypt_key[8] = 0;\n\t\tloopinfo.lo_encrypt_key_size = 8;\n\t\tpass = getpass(\"Init (up to 16 hex digits): \");\n\t\tfor (i = 0; i < 16 && pass[i]; i++)\n\t\t\tif (isxdigit(pass[i]))\n\t\t\t\tloopinfo.lo_init[i >> 3] |= (pass[i] > '9' ?\n\t\t\t\t\t\t\t     (islower(pass[i]) ? toupper(pass[i]) :\n\t\t\t\t\t\t\t      pass[i]) - 'A' + 10 : pass[i] - '0') << (i & 7) * 4;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/sundries.c","index":-1},"region":{"startLine":131,"endLine":131,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tif (strings == NULL)\n\t\treturn NULL;\n\n\tlist = cons(strtok(strings, \",\"), NULL);\n\n\twhile ((t = strtok(NULL, \",\")) != NULL)\n\t\tlist = cons(t, list);\n\n\treturn list;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":1}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_INFORMATION_LEAK_INTERNAL","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Internal information leak","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":134,"endLine":134,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tif (!loop_known)\n\t\t\tloop_known = -1;\n\t}\n\n\tif (!somedev)\n\t\terror(\"mount: could not find any device /dev/loop#\");\n\telse if (!someloop) {\n\t\tif (loop_known == 1)\n\t\t\terror(\"mount: Could not find any loop device.\\n\"\n\t\t\t      \"       Maybe /dev/loop# has a wrong major number?\");\n\t\telse if (loop_known == -1)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":873,"endLine":873,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t\t*p = tolower(*p);\n\t\t\t\t\t\tu++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (u && is_in_proc(lowtype))\n\t\t\t\t\terror(\"mount: probably you meant %s\", lowtype);\n\t\t\t\telse if (!strncmp(lowtype, \"iso\", 3) && is_in_proc(\"iso9660\"))\n\t\t\t\t\terror(\"mount: maybe you meant iso9660 ?\");\n\t\t\t\tfree(lowtype);\n\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":882,"endLine":882,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);\n\t\t\tbreak;\n\t\tcase ENOTBLK:\n\t\t\tif (stat(spec, &statbuf))\t/* strange ... */\n\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))\n\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":875,"endLine":875,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (u && is_in_proc(lowtype))\n\t\t\t\t\terror(\"mount: probably you meant %s\", lowtype);\n\t\t\t\telse if (!strncmp(lowtype, \"iso\", 3) && is_in_proc(\"iso9660\"))\n\t\t\t\t\terror(\"mount: maybe you meant iso9660 ?\");\n\t\t\t\tfree(lowtype);\n\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);\n\t\t\tbreak;\n\t\tcase ENOTBLK:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":856,"endLine":856,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase EIO:\n\t\t\terror(\"mount: %s: can't read superblock\", spec);\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tif (is_in_proc(type) || !strcmp(type, \"guess\"))\n\t\t\t\terror(\"mount: %s has wrong major or minor number\", spec);\n\t\t\telse if (procfs) {\n\t\t\t\tchar *lowtype, *p;\n\t\t\t\tint u;\n\n\t\t\t\terror(\"mount: fs type %s not supported by kernel\", type);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1095,"endLine":1095,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tfor (cp = childhead.nxt; cp; cp = cp->nxt) {\n\t\tpid_t p = -1;\n\t\tif (optfork) {\n\t\t\tp = fork();\n\t\t\tif (p == -1)\n\t\t\t\terror(\"mount: cannot fork: %s\", strerror(errno));\n\t\t\telse if (p != 0)\n\t\t\t\tcp->pid = p;\n\t\t}\n\n\t\t/* if child, or not forked, do the mounting */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":153,"endLine":153,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase EINVAL:\n\t\terror(\"umount: %s: not mounted\", dev);\n\t\tbreak;\n\tcase EIO:\n\t\terror(\"umount: %s: can't write superblock\", dev);\n\t\tbreak;\n\tcase EBUSY:\n\t\t/* Let us hope fstab has a line \"proc /proc ...\"\n\t\t   and not \"none /proc ...\" */\n\t\terror(\"umount: %s: device is busy\", dev);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":897,"endLine":897,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\terror(\"mount: %s is not a valid block device\", spec);\n\t\t\tbreak;\n\t\tcase EACCES:\t/* pre-linux 1.1.38, 1.1.41 and later */\n\t\tcase EROFS:\t/* linux 1.1.38 and later */\n\t\t\tif (added_ro) {\n\t\t\t\terror(\"mount: block device %s is not permitted on its filesystem\", spec);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tadded_ro = 1;\n\t\t\t\tif (loop) {\n\t\t\t\t\topts = opts0;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":150,"endLine":150,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tswitch (err) {\n\tcase ENXIO:\n\t\terror(\"umount: %s: invalid block device\", dev);\n\t\tbreak;\n\tcase EINVAL:\n\t\terror(\"umount: %s: not mounted\", dev);\n\t\tbreak;\n\tcase EIO:\n\t\terror(\"umount: %s: can't write superblock\", dev);\n\t\tbreak;\n\tcase EBUSY:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":808,"endLine":808,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */\n\t\t\t\t\terror(\"mount: proc already mounted\");\n\t\t\t} else {\n\t\t\t\terror(\"mount: %s already mounted or %s busy\", spec, node);\n\t\t\t\talready(spec, node);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tif (lstat(node, &statbuf))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":818,"endLine":818,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (lstat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s does not exist\", node);\n\t\t\telse if (stat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s is a symbolic link to nowhere\", node);\n\t\t\telse if (stat(spec, &statbuf))\n\t\t\t\terror(\"mount: special device %s does not exist\", spec);\n\t\t\telse {\n\t\t\t\terrno = mnt_err;\n\t\t\t\tperror(\"mount\");\n\t\t\t}\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":137,"endLine":138,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (!somedev)\n\t\terror(\"mount: could not find any device /dev/loop#\");\n\telse if (!someloop) {\n\t\tif (loop_known == 1)\n\t\t\terror(\"mount: Could not find any loop device.\\n\"\n\t\t\t      \"       Maybe /dev/loop# has a wrong major number?\");\n\t\telse if (loop_known == -1)\n\t\t\terror(\"mount: Could not find any loop device, and, according to %s,\\n\"\n\t\t\t      \"       this kernel does not know about the loop device.\\n\"\n\t\t\t      \"       (If so, then recompile or `insmod loop.o'.)\", PROC_DEVICES);\n\t\telse"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":806,"endLine":806,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {\n\t\t\t\t/* heuristic: if /proc/version exists, then probably proc is mounted */\n\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */\n\t\t\t\t\terror(\"mount: proc already mounted\");\n\t\t\t} else {\n\t\t\t\terror(\"mount: %s already mounted or %s busy\", spec, node);\n\t\t\t\talready(spec, node);\n\t\t\t}\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":892,"endLine":892,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\terror(\"mount: %s is not a valid block device\", spec);\n\t\t\tbreak;\n\t\tcase EACCES:\t/* pre-linux 1.1.38, 1.1.41 and later */\n\t\tcase EROFS:\t/* linux 1.1.38 and later */\n\t\t\tif (added_ro) {\n\t\t\t\terror(\"mount: block device %s is not permitted on its filesystem\", spec);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":794,"endLine":794,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase EPERM:\n\t\t\tif (geteuid() == 0) {\n\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))\n\t\t\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\t\telse\n\t\t\t\t\terror(\"mount: permission denied\");\n\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (flags & MS_REMOUNT) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":112,"endLine":112,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tmc->mnt_opts = mnt->mnt_opts;\n\t\tmc->nxt = NULL;\n\t}\n\tmc0->prev = mc;\n\tif (ferror(mfp->mntent_fp)) {\n\t\terror(\"warning: error reading %s: %s\", fnam, strerror(errno));\n\t\tmc0->nxt = mc0->prev = NULL;\n\t}\n\tmy_endmntent(mfp);\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":147,"endLine":147,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"/* complain about a failed umount */\nstatic void complain(int err, const char *dev)\n{\n\tswitch (err) {\n\tcase ENXIO:\n\t\terror(\"umount: %s: invalid block device\", dev);\n\t\tbreak;\n\tcase EINVAL:\n\t\terror(\"umount: %s: not mounted\", dev);\n\t\tbreak;\n\tcase EIO:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":861,"endLine":861,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: %s has wrong major or minor number\", spec);\n\t\t\telse if (procfs) {\n\t\t\t\tchar *lowtype, *p;\n\t\t\t\tint u;\n\n\t\t\t\terror(\"mount: fs type %s not supported by kernel\", type);\n\n\t\t\t\t/* maybe this loser asked for FAT or ISO9660 or isofs */\n\t\t\t\tlowtype = xstrdup(type);\n\t\t\t\tu = 0;\n\t\t\t\tfor (p = lowtype; *p; p++) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":884,"endLine":885,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tbreak;\n\t\tcase ENOTBLK:\n\t\t\tif (stat(spec, &statbuf))\t/* strange ... */\n\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))\n\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":1263,"endLine":1263,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tswitch (argc) {\n\tcase 0:\n\t\t/* mount -a */\n\t\tresult = mount_all(types, options);\n\t\tif (result == 0 && mount_verbose)\n\t\t\terror(\"not mounted anything\");\n\t\tbreak;\n\n\tcase 1:\n\t\t/* mount [-nfrvw] [-o options] special | node */\n\t\tif (types != NULL)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":167,"endLine":167,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase EPERM:\n\t\terror(\"umount: %s: must be superuser to umount\", dev);\n\t\tbreak;\n\tcase EACCES:\n\t\terror(\"umount: %s: block devices not permitted on fs\", dev);\n\t\tbreak;\n\tdefault:\n\t\terror(\"umount: %s: %s\", dev, strerror(err));\n\t\tbreak;\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":814,"endLine":814,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\talready(spec, node);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tif (lstat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s does not exist\", node);\n\t\t\telse if (stat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s is a symbolic link to nowhere\", node);\n\t\t\telse if (stat(spec, &statbuf))\n\t\t\t\terror(\"mount: special device %s does not exist\", spec);\n\t\t\telse {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":341,"endLine":341,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tgoto leave;\n\t}\n\n\tmftmp = my_setmntent(MOUNTED_TEMP, \"w\");\n\tif (mftmp == NULL || mftmp->mntent_fp == NULL) {\n\t\terror(\"can't open %s (%s) - mtab not updated\", MOUNTED_TEMP, strerror(errno));\n\t\tgoto leave;\n\t}\n\n\twhile ((mnt = my_getmntent(mfp))) {\n\t\tif (streq(mnt->mnt_dir, dir)) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":912,"endLine":913,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\tstrcat(opts, \",ro\");\n\t\t\t\t} else\n\t\t\t\t\topts = \"ro\";\n\t\t\t\tif (type && !strcmp(type, \"guess\"))\n\t\t\t\t\ttype = 0;\n\t\t\t\terror(\"mount: %s%s is write-protected, mounting read-only\",\n\t\t\t\t      loop ? \"\" : \"block device \", spec0);\n\t\t\t\treturn try_mount_one(spec0, node0, type, opts, freq, pass, bg);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"mount: %s\", strerror(mnt_err));"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":170,"endLine":170,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase EACCES:\n\t\terror(\"umount: %s: block devices not permitted on fs\", dev);\n\t\tbreak;\n\tdefault:\n\t\terror(\"umount: %s: %s\", dev, strerror(err));\n\t\tbreak;\n\t}\n}\n\n/* Umount a single device.  Return a status code, so don't exit"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":762,"endLine":762,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tmntFILE *mfp;\n\n\t\t\t\tlock_mtab();\n\t\t\t\tmfp = my_setmntent(MOUNTED, \"a+\");\n\t\t\t\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\t\t\t\terror(\"mount: can't open %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif ((my_addmntent(mfp, &mnt)) == 1)\n\t\t\t\t\t\terror(\"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t\tmy_endmntent(mfp);\n\t\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":144,"endLine":146,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\telse if (loop_known == -1)\n\t\t\terror(\"mount: Could not find any loop device, and, according to %s,\\n\"\n\t\t\t      \"       this kernel does not know about the loop device.\\n\"\n\t\t\t      \"       (If so, then recompile or `insmod loop.o'.)\", PROC_DEVICES);\n\t\telse\n\t\t\terror(\"mount: Could not find any loop device. Maybe this kernel does not know\\n\"\n\t\t\t      \"       about the loop device (then recompile or `insmod loop.o'), or\\n\"\n\t\t\t      \"       maybe /dev/loop# has the wrong major number?\");\n\t} else\n\t\terror(\"mount: could not find any free loop device\");\n\treturn 0;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":849,"endLine":849,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase EMFILE:\n\t\t\terror(\"mount table full\");\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\terror(\"mount: %s: can't read superblock\", spec);\n\t\t\tbreak;\n\t\tcase ENODEV:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":840,"endLine":842,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\t      \"       or too many mounted file systems\", spec);\n\n\t\t\t\t\tif (stat(spec, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)\n\t\t\t\t\t    && (fd = open(spec, O_RDONLY)) >= 0) {\n\t\t\t\t\t\tif (ioctl(fd, BLKGETSIZE, &size) == 0 && size <= 2)\n\t\t\t\t\t\t\terror\n\t\t\t\t\t\t\t    (\"       (aren't you trying to mount an extended partition,\\n\"\n\t\t\t\t\t\t\t     \"       instead of some logical partition inside?)\");\n\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":834,"endLine":835,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tint fd, size;\n\n\t\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\t\terror(\"mount: %s not mounted already, or bad option\", node);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"mount: wrong fs type, bad option, bad superblock on %s,\\n\"\n\t\t\t\t\t      \"       or too many mounted file systems\", spec);\n\n\t\t\t\t\tif (stat(spec, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)\n\t\t\t\t\t    && (fd = open(spec, O_RDONLY)) >= 0) {\n\t\t\t\t\t\tif (ioctl(fd, BLKGETSIZE, &size) == 0 && size <= 2)\n\t\t\t\t\t\t\terror"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":140,"endLine":142,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\telse if (!someloop) {\n\t\tif (loop_known == 1)\n\t\t\terror(\"mount: Could not find any loop device.\\n\"\n\t\t\t      \"       Maybe /dev/loop# has a wrong major number?\");\n\t\telse if (loop_known == -1)\n\t\t\terror(\"mount: Could not find any loop device, and, according to %s,\\n\"\n\t\t\t      \"       this kernel does not know about the loop device.\\n\"\n\t\t\t      \"       (If so, then recompile or `insmod loop.o'.)\", PROC_DEVICES);\n\t\telse\n\t\t\terror(\"mount: Could not find any loop device. Maybe this kernel does not know\\n\"\n\t\t\t      \"       about the loop device (then recompile or `insmod loop.o'), or\\n\"\n\t\t\t      \"       maybe /dev/loop# has the wrong major number?\");\n\t} else"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":796,"endLine":796,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))\n\t\t\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\t\telse\n\t\t\t\t\terror(\"mount: permission denied\");\n\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\terror(\"mount: %s is busy\", node);\n\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":889,"endLine":889,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\terror(\"mount: %s is not a valid block device\", spec);\n\t\t\tbreak;\n\t\tcase EACCES:\t/* pre-linux 1.1.38, 1.1.41 and later */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":765,"endLine":765,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\tmfp = my_setmntent(MOUNTED, \"a+\");\n\t\t\t\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\t\t\t\terror(\"mount: can't open %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t} else {\n\t\t\t\t\tif ((my_addmntent(mfp, &mnt)) == 1)\n\t\t\t\t\t\terror(\"mount: error writing %s: %s\", MOUNTED, strerror(errno));\n\t\t\t\t\tmy_endmntent(mfp);\n\t\t\t\t}\n\t\t\t\tunlock_mtab();\n\t\t\t}\n\t\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":164,"endLine":164,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tbreak;\n\tcase ENOENT:\n\t\terror(\"umount: %s: not found\", dev);\n\t\tbreak;\n\tcase EPERM:\n\t\terror(\"umount: %s: must be superuser to umount\", dev);\n\t\tbreak;\n\tcase EACCES:\n\t\terror(\"umount: %s: block devices not permitted on fs\", dev);\n\t\tbreak;\n\tdefault:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":804,"endLine":804,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\terror(\"mount: %s is busy\", node);\n\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {\n\t\t\t\t/* heuristic: if /proc/version exists, then probably proc is mounted */\n\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */\n\t\t\t\t\terror(\"mount: proc already mounted\");\n\t\t\t} else {\n\t\t\t\terror(\"mount: %s already mounted or %s busy\", spec, node);\n\t\t\t\talready(spec, node);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":641,"endLine":641,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tloopdev = opt_loopdev;\n\n\tlooptype = (type && strncmp(\"lo@\", type, 3) == 0);\n\tif (looptype) {\n\t\tif (loopdev)\n\t\t\terror(\"mount: loop device specified twice\");\n\t\tloopdev = type + 3;\n\t\ttype = opt_vfstype;\n\t} else if (opt_vfstype) {\n\t\tif (type)\n\t\t\terror(\"mount: type specified twice\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":161,"endLine":161,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t/* Let us hope fstab has a line \"proc /proc ...\"\n\t\t   and not \"none /proc ...\" */\n\t\terror(\"umount: %s: device is busy\", dev);\n\t\tbreak;\n\tcase ENOENT:\n\t\terror(\"umount: %s: not found\", dev);\n\t\tbreak;\n\tcase EPERM:\n\t\terror(\"umount: %s: must be superuser to umount\", dev);\n\t\tbreak;\n\tcase EACCES:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":918,"endLine":918,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t      loop ? \"\" : \"block device \", spec0);\n\t\t\t\treturn try_mount_one(spec0, node0, type, opts, freq, pass, bg);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"mount: %s\", strerror(mnt_err));\n\t\t\tbreak;\n\t\t}\n\treturn EX_FAIL;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":490,"endLine":490,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tint ret = 1;\n\n\tif ((mc = getmntfile(node)) != NULL)\n\t\terror(\"mount: according to mtab, %s is already mounted on %s\", mc->mnt_fsname, node);\n\telse if ((mc = getmntfile(spec)) != NULL)\n\t\terror(\"mount: according to mtab, %s is mounted on %s\", spec, mc->mnt_dir);\n\telse\n\t\tret = 0;\n\treturn ret;\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":163,"endLine":163,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tmc->nxt = mc->prev = NULL;\n\n\tfnam = _PATH_FSTAB;\n\tmfp = my_setmntent(fnam, \"r\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\terror(\"warning: can't open %s: %s\", _PATH_FSTAB, strerror(errno));\n\t\treturn;\n\t}\n\tread_mntentchn(mfp, fnam, mc);\n}\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":728,"endLine":728,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t} else if (fork() != -1) {\n\t\t\t\t\tint status;\n\t\t\t\t\twait(&status);\n\t\t\t\t\treturn status;\n\t\t\t\t} else\n\t\t\t\t\terror(\"cannot fork: %s\", strerror(errno));\n\t\t\t}\n\t\t}\n\n\tblock_signals(SIG_BLOCK);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":800,"endLine":800,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;\n\t\tcase EBUSY:\n\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\terror(\"mount: %s is busy\", node);\n\t\t\t} else if (!strcmp(type, \"proc\") && !strcmp(node, \"/proc\")) {\n\t\t\t\t/* heuristic: if /proc/version exists, then probably proc is mounted */\n\t\t\t\tif (stat(\"/proc/version\", &statbuf))\t/* proc mounted? */\n\t\t\t\t\terror(\"mount: %s is busy\", node);\t/* no */\n\t\t\t\telse if (!all || mount_verbose)\t/* yes, don't mention it */"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":786,"endLine":786,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\tblock_signals(SIG_UNBLOCK);\n\n\t/* Mount failed, complain, but don't die.  */\n\n\tif (type == 0)\n\t\terror(\"mount: you must specify the filesystem type\");\n\telse\n\t\tswitch (mnt_err) {\n\t\tcase EPERM:\n\t\t\tif (geteuid() == 0) {\n\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":887,"endLine":887,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))\n\t\t\t\terror(\"mount: the kernel does not recognize %s as a block device\\n\"\n\t\t\t\t      \"       (maybe `insmod driver'?)\", spec);\n\t\t\telse if (S_ISREG(statbuf.st_mode))\n\t\t\t\terror(\"mount: %s is not a block device (maybe try `-o loop'?)\", spec);\n\t\t\telse\n\t\t\t\terror(\"mount: %s is not a block device\", spec);\n\t\t\tbreak;\n\t\tcase ENXIO:\n\t\t\terror(\"mount: %s is not a valid block device\", spec);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/umount.c","index":-1},"region":{"startLine":158,"endLine":158,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\terror(\"umount: %s: can't write superblock\", dev);\n\t\tbreak;\n\tcase EBUSY:\n\t\t/* Let us hope fstab has a line \"proc /proc ...\"\n\t\t   and not \"none /proc ...\" */\n\t\terror(\"umount: %s: device is busy\", dev);\n\t\tbreak;\n\tcase ENOENT:\n\t\terror(\"umount: %s: not found\", dev);\n\t\tbreak;\n\tcase EPERM:"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":646,"endLine":646,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\terror(\"mount: loop device specified twice\");\n\t\tloopdev = type + 3;\n\t\ttype = opt_vfstype;\n\t} else if (opt_vfstype) {\n\t\tif (type)\n\t\t\terror(\"mount: type specified twice\");\n\t\telse\n\t\t\ttype = opt_vfstype;\n\t}\n\n\tloop = ((flags & MS_LOOP) || loopdev || opt_offset || opt_encryption);"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":852,"endLine":852,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t}\n\t\tcase EMFILE:\n\t\t\terror(\"mount table full\");\n\t\t\tbreak;\n\t\tcase EIO:\n\t\t\terror(\"mount: %s: can't read superblock\", spec);\n\t\t\tbreak;\n\t\tcase ENODEV:\n\t\t\tif (is_in_proc(type) || !strcmp(type, \"guess\"))\n\t\t\t\terror(\"mount: %s has wrong major or minor number\", spec);\n\t\t\telse if (procfs) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":335,"endLine":335,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tlock_mtab();\n\n\tmfp = my_setmntent(MOUNTED, \"r\");\n\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\terror(\"cannot open %s (%s) - mtab not updated\", MOUNTED, strerror(errno));\n\t\tgoto leave;\n\t}\n\n\tmftmp = my_setmntent(MOUNTED_TEMP, \"w\");\n\tif (mftmp == NULL || mftmp->mntent_fp == NULL) {"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/fstab.c","index":-1},"region":{"startLine":142,"endLine":142,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tfnam = PROC_MOUNTS;\n\t\tif (mfp != NULL)\n\t\t\tfree(mfp);\n\t\tmfp = my_setmntent(fnam, \"r\");\n\t\tif (mfp == NULL || mfp->mntent_fp == NULL) {\n\t\t\terror(\"warning: can't open %s: %s\", MOUNTED, strerror(errsv));\n\t\t\treturn;\n\t\t}\n\t\tif (mount_verbose)\n\t\t\tprintf(\"mount: could not open %s - using %s instead\\n\", MOUNTED, PROC_MOUNTS);\n\t}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":816,"endLine":816,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\tbreak;\n\t\tcase ENOENT:\n\t\t\tif (lstat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s does not exist\", node);\n\t\t\telse if (stat(node, &statbuf))\n\t\t\t\terror(\"mount: mount point %s is a symbolic link to nowhere\", node);\n\t\t\telse if (stat(spec, &statbuf))\n\t\t\t\terror(\"mount: special device %s does not exist\", spec);\n\t\t\telse {\n\t\t\t\terrno = mnt_err;\n\t\t\t\tperror(\"mount\");"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":792,"endLine":792,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\telse\n\t\tswitch (mnt_err) {\n\t\tcase EPERM:\n\t\t\tif (geteuid() == 0) {\n\t\t\t\tif (stat(node, &statbuf) || !S_ISDIR(statbuf.st_mode))\n\t\t\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\t\telse\n\t\t\t\t\terror(\"mount: permission denied\");\n\t\t\t} else\n\t\t\t\terror(\"mount: must be superuser to use mount\");\n\t\t\tbreak;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/lomount.c","index":-1},"region":{"startLine":148,"endLine":148,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\telse\n\t\t\terror(\"mount: Could not find any loop device. Maybe this kernel does not know\\n\"\n\t\t\t      \"       about the loop device (then recompile or `insmod loop.o'), or\\n\"\n\t\t\t      \"       maybe /dev/loop# has the wrong major number?\");\n\t} else\n\t\terror(\"mount: could not find any free loop device\");\n\treturn 0;\n}\n\nint set_loop(const char *device, const char *file, int offset, const char *encryption, int *loopro)\n{"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":825,"endLine":825,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\terrno = mnt_err;\n\t\t\t\tperror(\"mount\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ENOTDIR:\n\t\t\terror(\"mount: mount point %s is not a directory\", node);\n\t\t\tbreak;\n\t\tcase EINVAL:\n\t\t\t{\n\t\t\t\tint fd, size;\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":832,"endLine":832,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\tcase EINVAL:\n\t\t\t{\n\t\t\t\tint fd, size;\n\n\t\t\t\tif (flags & MS_REMOUNT) {\n\t\t\t\t\terror(\"mount: %s not mounted already, or bad option\", node);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"mount: wrong fs type, bad option, bad superblock on %s,\\n\"\n\t\t\t\t\t      \"       or too many mounted file systems\", spec);\n\n\t\t\t\t\tif (stat(spec, &statbuf) == 0 && S_ISBLK(statbuf.st_mode)"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":878,"endLine":878,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\t\t\t\t\terror(\"mount: probably you meant %s\", lowtype);\n\t\t\t\telse if (!strncmp(lowtype, \"iso\", 3) && is_in_proc(\"iso9660\"))\n\t\t\t\t\terror(\"mount: maybe you meant iso9660 ?\");\n\t\t\t\tfree(lowtype);\n\t\t\t} else\n\t\t\t\terror(\"mount: %s has wrong device number or fs type %s not supported\", spec, type);\n\t\t\tbreak;\n\t\tcase ENOTBLK:\n\t\t\tif (stat(spec, &statbuf))\t/* strange ... */\n\t\t\t\terror(\"mount: %s is not a block device, and stat fails?\", spec);\n\t\t\telse if (S_ISBLK(statbuf.st_mode))"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":488,"endLine":488,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"{\n\tstruct mntentchn *mc;\n\tint ret = 1;\n\n\tif ((mc = getmntfile(node)) != NULL)\n\t\terror(\"mount: according to mtab, %s is already mounted on %s\", mc->mnt_fsname, node);\n\telse if ((mc = getmntfile(spec)) != NULL)\n\t\terror(\"mount: according to mtab, %s is mounted on %s\", spec, mc->mnt_dir);\n\telse\n\t\tret = 0;\n\treturn ret;"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]},{"ruleId":"C_PRECISION_LOSS","ruleIndex":-1,"kind":"fail","level":"warning","message":{"text":"Loss of precision","arguments":[]},"locations":[{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/mount.c","index":-1},"region":{"startLine":328,"endLine":328,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"   xiafs does not touch the 1st sector and has its magic in\n   the 2nd sector; ext2 does not touch the first two sectors. */\n\nstatic inline unsigned short swapped(unsigned short a)\n{\n\treturn (a >> 8) | (a << 8);\n}\n\n/*\n    char *fstype(const char *device);\n"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/mount.c","lineStart":328,"lineEnd":328,"columnStart":9,"columnEnd":27,"description":"(a >> 8) | (a << 8)","snippet":"   xiafs does not touch the 1st sector and has its magic in\n   the 2nd sector; ext2 does not touch the first two sectors. */\n\nstatic inline unsigned short swapped(unsigned short a)\n{\n\treturn (a >> 8) | (a << 8);\n}\n\n/*\n    char *fstype(const char *device);\n"},{"position":1,"source":"src/mount.c","lineStart":396,"lineEnd":396,"columnStart":73,"columnEnd":97,"description":"swapped(EXT2_SUPER_MAGIC)","snippet":"\n\tif (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))\n\t\tgoto io_error;\n\n\tif (ext2magic(sb.e2s) == EXT2_SUPER_MAGIC\n\t    || ext2magic(sb.e2s) == EXT2_PRE_02B_MAGIC || ext2magic(sb.e2s) == swapped(EXT2_SUPER_MAGIC))\n\t\ttype = \"ext2\";\n\n\telse if (minixmagic(sb.ms) == MINIX_SUPER_MAGIC || minixmagic(sb.ms) == MINIX_SUPER_MAGIC2)\n\t\ttype = \"minix\";\n"},{"position":2,"source":"src/mount.c","lineStart":396,"lineEnd":396,"columnStart":9,"columnEnd":30,"description":"ext2magic(sb.e2s) == EXT2_PRE_02B_MAGIC","snippet":"\n\tif (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))\n\t\tgoto io_error;\n\n\tif (ext2magic(sb.e2s) == EXT2_SUPER_MAGIC\n\t    || ext2magic(sb.e2s) == EXT2_PRE_02B_MAGIC || ext2magic(sb.e2s) == swapped(EXT2_SUPER_MAGIC))\n\t\ttype = \"ext2\";\n\n\telse if (minixmagic(sb.ms) == MINIX_SUPER_MAGIC || minixmagic(sb.ms) == MINIX_SUPER_MAGIC2)\n\t\ttype = \"minix\";\n"},{"position":3,"source":"src/mount.c","lineStart":395,"lineEnd":395,"columnStart":6,"columnEnd":27,"description":"ext2magic(sb.e2s) == EXT2_SUPER_MAGIC","snippet":"\t\treturn 0;\n\n\tif (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))\n\t\tgoto io_error;\n\n\tif (ext2magic(sb.e2s) == EXT2_SUPER_MAGIC\n\t    || ext2magic(sb.e2s) == EXT2_PRE_02B_MAGIC || ext2magic(sb.e2s) == swapped(EXT2_SUPER_MAGIC))\n\t\ttype = \"ext2\";\n\n\telse if (minixmagic(sb.ms) == MINIX_SUPER_MAGIC || minixmagic(sb.ms) == MINIX_SUPER_MAGIC2)\n\t\ttype = \"minix\";"},{"position":4,"source":"src/mount.c","lineStart":392,"lineEnd":392,"columnStart":43,"columnEnd":89,"description":"read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb)","snippet":"\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))\n\t\tgoto io_error;\n\n\tif (ext2magic(sb.e2s) == EXT2_SUPER_MAGIC\n\t    || ext2magic(sb.e2s) == EXT2_PRE_02B_MAGIC || ext2magic(sb.e2s) == swapped(EXT2_SUPER_MAGIC))\n\t\ttype = \"ext2\";"},{"position":5,"source":"src/mount.c","lineStart":392,"lineEnd":392,"columnStart":6,"columnEnd":35,"description":"lseek(fd, 1024, SEEK_SET) != 1024","snippet":"\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))\n\t\tgoto io_error;\n\n\tif (ext2magic(sb.e2s) == EXT2_SUPER_MAGIC\n\t    || ext2magic(sb.e2s) == EXT2_PRE_02B_MAGIC || ext2magic(sb.e2s) == swapped(EXT2_SUPER_MAGIC))\n\t\ttype = \"ext2\";"},{"position":6,"source":"src/mount.c","lineStart":389,"lineEnd":389,"columnStart":6,"columnEnd":11,"description":"fd < 0","snippet":"\t   to a block device */\n\tif (stat(device, &statbuf) || !S_ISBLK(statbuf.st_mode))\n\t\treturn 0;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;\n\n\tif (lseek(fd, 1024, SEEK_SET) != 1024 || read(fd, (char *)&sb, sizeof(sb)) != sizeof(sb))\n\t\tgoto io_error;\n"},{"position":7,"source":"src/mount.c","lineStart":385,"lineEnd":385,"columnStart":33,"columnEnd":33,"description":"S_ISBLK(statbuf.st_mode)","snippet":"\tstruct stat statbuf;\n\n\t/* opening and reading an arbitrary unknown path can have\n\t   undesired side effects - first check that `device' refers\n\t   to a block device */\n\tif (stat(device, &statbuf) || !S_ISBLK(statbuf.st_mode))\n\t\treturn 0;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;"},{"position":8,"source":"src/mount.c","lineStart":385,"lineEnd":385,"columnStart":6,"columnEnd":27,"description":"stat(device, &statbuf)","snippet":"\tstruct stat statbuf;\n\n\t/* opening and reading an arbitrary unknown path can have\n\t   undesired side effects - first check that `device' refers\n\t   to a block device */\n\tif (stat(device, &statbuf) || !S_ISBLK(statbuf.st_mode))\n\t\treturn 0;\n\n\tfd = open(device, O_RDONLY);\n\tif (fd < 0)\n\t\treturn 0;"},{"position":9,"source":"src/mount.c","lineStart":553,"lineEnd":553,"columnStart":11,"columnEnd":22,"description":"fstype(spec)","snippet":"\n\tif (*type && strcasecmp(*type, \"auto\") == 0)\n\t\t*type = NULL;\n\n\tif (!*type && !(flags & MS_REMOUNT)) {\n\t\t*type = fstype(spec);\n\t\tif (mount_verbose) {\n\t\t\tprintf(\"mount: you didn't specify a filesystem type for %s\\n\", spec);\n\t\t\tif (*type)\n\t\t\t\tprintf(\"       I will try type %s\\n\", *type);\n\t\t\telse"},{"position":10,"source":"src/mount.c","lineStart":734,"lineEnd":734,"columnStart":15,"columnEnd":74,"description":"try_mount5(spec, node, &type, flags & ~MS_NOSYS, mount_opts)","snippet":"\t\t\t}\n\t\t}\n\n\tblock_signals(SIG_BLOCK);\n\n\tif (fake || (try_mount5(spec, node, &type, flags & ~MS_NOSYS, mount_opts)) == 0)\n\t\t/* Mount succeeded, report this (if mount_verbose) and write mtab entry.  */\n\t{\n\t\tif (loop)\n\t\t\topt_loopdev = loopdev;\n"},{"position":11,"source":"src/mount.c","lineStart":734,"lineEnd":734,"columnStart":6,"columnEnd":6,"description":"if (fake || (try_mount5(spec, node, &type, flags & ~MS_NOSYS, mount_opts)) == 0)","snippet":"\t\t\t}\n\t\t}\n\n\tblock_signals(SIG_BLOCK);\n\n\tif (fake || (try_mount5(spec, node, &type, flags & ~MS_NOSYS, mount_opts)) == 0)\n\t\t/* Mount succeeded, report this (if mount_verbose) and write mtab entry.  */\n\t{\n\t\tif (loop)\n\t\t\topt_loopdev = loopdev;\n"},{"position":12,"source":"src/mount.c","lineStart":677,"lineEnd":677,"columnStart":6,"columnEnd":7,"description":"!fake","snippet":"\t\t\tif (loopro)\n\t\t\t\tflags |= MS_RDONLY;\n\t\t}\n\t}\n\n\tif (!fake && type && streq(type, \"nfs\")) {\n#if HAVE_NFS\n\t\tmnt_err = nfsmount(spec, node, &flags, &extra_opts, &mount_opts, bg);\n\t\tif (mnt_err)\n\t\t\treturn mnt_err;\n#else"},{"position":13,"source":"src/mount.c","lineStart":654,"lineEnd":654,"columnStart":6,"columnEnd":6,"description":"if (loop)","snippet":"\t}\n\n\tloop = ((flags & MS_LOOP) || loopdev || opt_offset || opt_encryption);\n\tloopfile = spec;\n\n\tif (loop) {\n\t\tflags |= MS_LOOP;\n\t\tif (fake) {\n\t\t\tif (mount_verbose)\n\t\t\t\tprintf(\"mount: skipping the setup of a loop device\\n\");\n\t\t} else {"},{"position":14,"source":"src/mount.c","lineStart":651,"lineEnd":651,"columnStart":31,"columnEnd":31,"description":"loop = ((flags & MS_LOOP) || loopdev || opt_offset || opt_encryption)","snippet":"\t\t\terror(\"mount: type specified twice\");\n\t\telse\n\t\t\ttype = opt_vfstype;\n\t}\n\n\tloop = ((flags & MS_LOOP) || loopdev || opt_offset || opt_encryption);\n\tloopfile = spec;\n\n\tif (loop) {\n\t\tflags |= MS_LOOP;\n\t\tif (fake) {"},{"position":15,"source":"src/mount.c","lineStart":644,"lineEnd":644,"columnStart":13,"columnEnd":13,"description":"} else if (opt_vfstype)","snippet":"\tif (looptype) {\n\t\tif (loopdev)\n\t\t\terror(\"mount: loop device specified twice\");\n\t\tloopdev = type + 3;\n\t\ttype = opt_vfstype;\n\t} else if (opt_vfstype) {\n\t\tif (type)\n\t\t\terror(\"mount: type specified twice\");\n\t\telse\n\t\t\ttype = opt_vfstype;\n\t}"},{"position":16,"source":"src/mount.c","lineStart":638,"lineEnd":638,"columnStart":14,"columnEnd":14,"description":"looptype = (type && strncmp(\"lo@\", type, 3) == 0)","snippet":"\t * immediately: maybe later other types of mountable objects will occur.\n\t */\n\n\tloopdev = opt_loopdev;\n\n\tlooptype = (type && strncmp(\"lo@\", type, 3) == 0);\n\tif (looptype) {\n\t\tif (loopdev)\n\t\t\terror(\"mount: loop device specified twice\");\n\t\tloopdev = type + 3;\n\t\ttype = opt_vfstype;"},{"position":17,"source":"src/mount.c","lineStart":623,"lineEnd":623,"columnStart":6,"columnEnd":6,"description":"if (all && (flags & MS_NOAUTO))","snippet":"\t\telse\n\t\t\tdie(EX_USAGE, \"mount: only root can mount %s on %s\", spec, node);\n\t}\n\n\t/* quietly succeed for fstab entries that don't get mounted automatically */\n\tif (all && (flags & MS_NOAUTO))\n\t\treturn 0;\n\n\tmount_opts = extra_opts;\n\n\t/*"},{"position":18,"source":"src/mount.c","lineStart":615,"lineEnd":615,"columnStart":6,"columnEnd":6,"description":"if (mount_suid && !(flags & MS_USER))","snippet":"\topts = xstrdup(opts0);\n\n\tparse_opts(xstrdup(opts), &flags, &extra_opts);\n\n\t/* root may allow certain types of mounts by ordinary users */\n\tif (mount_suid && !(flags & MS_USER)) {\n\t\tif (already(spec, node))\n\t\t\tdie(EX_USAGE, \"mount failed\");\n\t\telse\n\t\t\tdie(EX_USAGE, \"mount: only root can mount %s on %s\", spec, node);\n\t}"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/xmalloc.c","index":-1},"region":{"startLine":71,"endLine":71,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/xmalloc.c","lineStart":71,"lineEnd":71,"columnStart":16,"columnEnd":16,"description":"strncpy(t, s, n)","snippet":"\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;\n\n\treturn t;\n}"},{"position":1,"source":"src/xmalloc.c","lineStart":67,"lineEnd":67,"columnStart":6,"columnEnd":11,"description":"s == NULL","snippet":"\nchar *xstrndup(const char *s, int n)\n{\n\tchar *t;\n\n\tif (s == NULL || n < 0)\n\t\tfatal_error(EX_SOFTWARE, \"bad xstrndup call (%sn = %d)\", s == NULL ? \"\" : \"s = NULL, \", n);\n\n\tt = xmalloc(n + 1);\n\tstrncpy(t, s, n);\n\tt[n] = 0;"}]}},{"id":-1,"physicalLocation":{"artifactLocation":{"uri":"src/net.c","index":-1},"region":{"startLine":198,"endLine":198,"charOffset":-1,"byteOffset":-1,"snippet":{"text":"{\n\tstruct list *act;\n\tint hold;\n\tstruct icmp_filter filt;\n\tmemset(&filt, 0, sizeof(filt));\n\tfilt.data = ~(1<<ICMP_ECHOREPLY);\n\n\tif (tlist != NULL) {\n\t\t/* Have at least on ping target to configure, get ICMP settings. */\n\t\tstruct protoent *proto;\n\t\tconst char pname[] = \"icmp\";"}}},"logicalLocations":[],"annotations":[],"relationships":[],"properties":{"tags":[],"x-severity":2,"x-trace":[{"position":0,"source":"src/net.c","lineStart":198,"lineEnd":198,"columnStart":14,"columnEnd":33,"description":"~(1<<ICMP_ECHOREPLY)","snippet":"{\n\tstruct list *act;\n\tint hold;\n\tstruct icmp_filter filt;\n\tmemset(&filt, 0, sizeof(filt));\n\tfilt.data = ~(1<<ICMP_ECHOREPLY);\n\n\tif (tlist != NULL) {\n\t\t/* Have at least on ping target to configure, get ICMP settings. */\n\t\tstruct protoent *proto;\n\t\tconst char pname[] = \"icmp\";"}]}}],"stacks":[],"codeFlows":[],"graphs":[],"graphTraversals":[],"relatedLocations":[],"suppressions":[],"rank":-1.0,"attachments":[],"workItemUris":[],"fixes":[],"taxa":[]}],"runAggregates":[],"redactionTokens":[],"newlineSequences":["\r\n","\n"],"threadFlowLocations":[],"taxonomies":[],"addresses":[],"translations":[],"policies":[],"webRequests":[],"webResponses":[]}],"inlineExternalProperties":[],"properties":{"tags":[],"rulesVersion":"3.13.0.99861.d2cd4c1e"}}